{"0": {
    "doc": "About Us",
    "title": "Core Team",
    "content": "| Clément Michaud | Amir Zarrinkafsh | James Elliott | ",
    "url": "/docs/about-us.html#core-team",
    "relUrl": "/about-us.html#core-team"
  },"1": {
    "doc": "About Us",
    "title": "Contact Options",
    "content": "Several contact options exist for our community, the primary one being Matrix. These are in addition to GitHub issues for creating a new issue. Matrix . Community members are invited to join the Matrix Space which includes both the Support Room and the Contributing Room. | The core team members are identified as administrators in the Space and individual Rooms. | All channels are linked to Discord. | . Discord . Community members are invited to join the Discord Server. | The core team members are identified by the CORE TEAM role in Discord. | The #support and #contributing channels are linked to Matrix. | . Email . You can contact the core team by email via team@authelia.com. Please note the security@authelia.com is also available but is strictly reserved for security related matters. ",
    "url": "/docs/about-us.html#contact-options",
    "relUrl": "/about-us.html#contact-options"
  },"2": {
    "doc": "About Us",
    "title": "About Us",
    "content": " ",
    "url": "/docs/about-us.html",
    "relUrl": "/about-us.html"
  },"3": {
    "doc": "Access Control",
    "title": "Access Control",
    "content": "Authelia allows to define a fine-grained rule-based access control policy in configuration. This list of rules is tested against any requests protected by Authelia and defines the level of authentication the user must pass to get access to the resource. For instance a rule can look like this: . - domain: dev.example.com resources: - \"^/groups/dev/.*$\" subject: \"group:dev\" policy: two_factor . This rule matches when the request targets the domain dev.example.com and the path matches the regular expression ^/groups/dev/.*$. In that case, a two-factor policy is applied requiring the user to authenticate with two factors. ",
    "url": "/docs/features/access-control.html",
    "relUrl": "/features/access-control.html"
  },"4": {
    "doc": "Access Control",
    "title": "Configuration",
    "content": "Please check the dedicated documentation . ",
    "url": "/docs/features/access-control.html#configuration",
    "relUrl": "/features/access-control.html#configuration"
  },"5": {
    "doc": "Access Control",
    "title": "Access Control",
    "content": " ",
    "url": "/docs/configuration/access-control.html",
    "relUrl": "/configuration/access-control.html"
  },"6": {
    "doc": "Access Control",
    "title": "Configuration",
    "content": "access_control: default_policy: deny networks: - name: internal networks: - 10.0.0.0/8 - 172.16.0.0/12 - 192.168.0.0/18 rules: - domain: public.example.com policy: bypass networks: - internal - 1.1.1.1 subject: - [\"user:adam\", \"user:fred\"] - [\"group:admins\"] methods: - GET - HEAD resources: - \"^/api.*\" . ",
    "url": "/docs/configuration/access-control.html#configuration",
    "relUrl": "/configuration/access-control.html#configuration"
  },"7": {
    "doc": "Access Control",
    "title": "Options",
    "content": "default_policy . type: string . default: deny . required: no . The default policy defines the policy applied if no rules section apply to the information known about the request. It is recommended that this is configured to deny for security reasons. Sites which you do not wish to secure at all with Authelia should not be configured in your reverse proxy to perform authentication with Authelia at all for performance reasons. See Policies for more information. networks (global) . type: list . required: no . The main/global networks section contains a list of networks with a name label that can be reused in the rules section instead of redefining the same networks over and over again. This additionally makes complicated network related configuration a lot cleaner and easier to read. This section has two options, name and networks. Where the networks section is a list of IP addresses in CIDR notation and where name is a friendly name to label the collection of networks for reuse in the networks section of the rules section below. This configuration option does nothing by itself, it’s only useful if you use these aliases in the rules section below. rules . type: list . required: no . The rules have many configuration options. A rule matches when all criteria of the rule match the request excluding the policy which is the policy applied to the request. A rule defines two primary things: . | the policy applied when all criteria match. | the matching criteria of the request presented to the reverse proxy . | . The criteria is broken into several parts: . | domain: domain or list of domains targeted by the request. | resources: pattern or list of patterns that the path should match. | subject: the user or group of users to define the policy for. | networks: the network addresses, ranges (CIDR notation) or groups from where the request originates. | methods: the http methods used in the request. | . A rule is matched when all criteria of the rule match. Rules are evaluated in sequential order, and the first rule that is a match for a given request is the rule applied; subsequent rules have no effect. This is particularly important for bypass rules. Bypass rules should generally appear near the top of the rules list. However you need to carefully evaluate your rule list in order to see which rule matches a particular scenario. A comprehensive understanding of how rules apply is also recommended. policy . type: string . required: yes . The specific policy to apply to the selected rule. This is not criteria for a match, this is the action to take when a match is made. domain . type: list(string) . required: yes . This criteria matches the domain name and has two methods of configuration, either as a single string or as a list of strings. When it’s a list of strings the rule matches when any of the domains in the list match the request domain. Rules may start with a few different wildcards: . | The standard wildcard is *., which when in front of a domain means that any subdomain is effectively a match. For example *.example.com would match abc.example.com and secure.example.com. When using a wildcard like this the string must be quoted like \"*.example.com\". | The user wildcard is {user}., which when in front of a domain dynamically matches the username of the user. For example {user}.example.com would match fred.example.com if the user logged in was named fred. Note: we’re considering refactoring this to just be regex which would likely allow many additional possibilities. | The group wildcard is {group}., which when in front of a domain dynamically matches if the logged in user has the group in that location. For example {group}.example.com would match admins.example.com if the user logged in was in the following groups admins,users,people because admins is in the list. | . Domains in this section must be the domain configured in the session configuration or subdomains of that domain. This is because a website can only write cookies for a domain it is part of. It is theoretically possible for us to do this with multiple domains however we would have to be security conscious in our implementation, and it is not currently a priority. Examples: . Single domain of *.example.com matched. All rules in this list are effectively the same rule just expressed in different ways. access_control: rules: - domain: \"*.example.com\" policy: bypass - domain: - \"*.example.com\" policy: bypass . Multiple domains matched. These rules would match either apple.example.com or orange.example.com. All rules in this list are effectively the same rule just expressed in different ways. access_control: rules: - domain: [\"apple.example.com\", \"banana.example.com\"] policy: bypass - domain: - apple.example.com - banana.example.com policy: bypass . subject . type: list(list(string)) . required: no . Note: this rule criteria may not be used for the bypass policy the minimum required authentication level to identify the subject is one_factor. We have taken an opinionated stance on preventing this configuration as it could result in problematic security scenarios with badly thought out configurations and cannot see a likely configuration scenario that would require users to do this. If you have a scenario in mind please open an issue on GitHub. This criteria matches identifying characteristics about the subject. Currently this is either user or groups the user belongs to. This allows you to effectively control exactly what each user is authorized to access or to specifically require two-factor authentication to specific users. Subjects are prefixed with either user: or group: to identify which part of the identity to check. The format of this rule is unique in as much as it is a list of lists. The logic behind this format is to allow for both OR and AND logic. The first level of the list defines the OR logic, and the second level defines the AND logic. Additionally each level of these lists does not have to be explicitly defined. Example: . Matches when the user has the username john, or the user is in the groups admin and app-name, or the user is in the group super-admin. All rules in this list are effectively the same rule just expressed in different ways. access_control: rules: - domain: example.com policy: two_factor subject: - \"user:john\" - [\"group:admin\", \"group:app-name\"] - \"group:super-admin\" - domain: example.com policy: two_factor subject: - [\"user:john\"] - [\"group:admin\", \"group:app-name\"] - [\"group:super-admin\"] . Matches when the user is in the super-admin group. All rules in this list are effectively the same rule just expressed in different ways. access_control: rules: - domain: example.com policy: one_factor subject: \"group:super-admin\" - domain: example.com policy: one_factor subject: - \"group:super-admin\" - domain: example.com policy: one_factor subject: - [\"group:super-admin\"] . methods . type: list(string) . required: no . This criteria matches the HTTP request method. This is primarily useful when trying to bypass authentication for specific request types when those requests would prevent essential or public operation of the website. An example is when you need to do CORS preflight requests you could apply the bypass policy to OPTIONS requests. It’s important to note that Authelia cannot preserve request data when redirecting the user. For example if the user had permission to do GET requests, their authentication level was one_factor, and POST requests required them to do two_factor authentication, they would lose the form data. Additionally it is sometimes not possible to redirect users who have done requests other than HEAD or GET which means the user experience may suffer. These are the reasons it’s only recommended to use this to increase security where essential and for CORS preflight. Example: . access_control: rules: - domain: example.com policy: bypass methods: - OPTIONS . The valid request methods are: OPTIONS, HEAD, GET, POST, PUT, PATCH, DELETE, TRACE, CONNECT. Additional information about HTTP request methods can be found on the MDN. networks . type: list(string) . required: no . This criteria is a list of values which can be an IP Address, network address range in CIDR notation, or an alias from the global section. It matches against the first address in the X-Forwarded-For header, or if there are none it will fall back to the IP address of the packet TCP source IP address. For this reason it’s important for you to configure the proxy server correctly in order to accurately match requests with this criteria. Note: you may combine CIDR networks with the alias rules as you please. The main use case for this criteria is adjust the security requirements of a resource based on the location of a user. You can theoretically consider a specific network to be one of the factors involved in authentiation, you can deny specific networks, etc. For example if you have an application exposed on both the local networks and the external networks, you are able to distinguish between those requests and apply differing policies to each. Either denying access when the user is on the external networks and allowing specific external clients to access it as well as internal clients, or by requiring less privileges when a user is on the local networks. There are a large number of scenarios regarding networks and the order of the rules. This provides a lot of flexibility for administrators to tune the security to their specific needs if desired. Examples: . Require two_factor for all clients other than internal clients and 112.134.145.167. The first two rules in this list are effectively the same rule just expressed in different ways. access_control: default_policy: two_factor networks: - name: internal networks: - 10.0.0.0/8 - 172.16.0.0/12 - 192.168.0.0/18 rules: - domain: secure.example.com policy: one_factor networks: - 10.0.0.0/8 - 172.16.0.0/12 - 192.168.0.0/18 - 112.134.145.167/32 - domain: secure.example.com policy: one_factor networks: - internal - 112.134.145.167/32 - domain: secure.example.com policy: two_factor . resources . type: list(string) . required: no . This criteria matches the path and query of the request using regular expressions. The rule is expressed as a list of strings. If any one of the regular expressions in the list matches the request it’s considered a match. A useful tool for debugging these regular expressions is called Rego. Note: Prior to 4.27.0 the regular expressions only matched the path excluding the query parameters. After 4.27.0 they match the entire path including the query parameters. When upgrading you may be required to alter some of your resource rules to get them to operate as they previously did. It’s important when configuring resource rules that you enclose them in quotes otherwise you may run into some issues with escaping the expressions. Failure to do so may prevent Authelia from starting. It’s technically optional but will likely save you a lot of time if you do it for all resource rules. Examples: . Applies the bypass policy when the domain is app.example.com and the url is /api, or starts with either /api/ or /api?. access_control: rules: - domain: app.example.com policy: bypass resources: - \"^/api([/?].*)?$\" . ",
    "url": "/docs/configuration/access-control.html#options",
    "relUrl": "/configuration/access-control.html#options"
  },"8": {
    "doc": "Access Control",
    "title": "Policies",
    "content": "With Authelia you can define a list of rules that are going to be evaluated in sequential order when authorization is delegated to Authelia. The first matching rule of the list defines the policy applied to the resource, if no rule matches the resource a customizable default policy is applied. deny . This is the policy applied by default, and is what we recommend as the default policy for all installs. Its effect is literally to deny the user access to the resource. Additionally you can use this policy to conditionally deny access in desired situations. Examples include denying access to an API that has no authentication mechanism built in. bypass . This policy skips all authentication and allows anyone to use the resource. This policy is not available with a rule that includes a subject restriction because the minimum authentication level required to obtain information about the subject is one_factor. one_factor . This policy requires the user at minimum complete 1FA successfully (username and password). This means if they have performed 2FA then they will be allowed to access the resource. two_factor . This policy requires the user to complete 2FA successfully. This is currently the highest level of authentication policy available. ",
    "url": "/docs/configuration/access-control.html#policies",
    "relUrl": "/configuration/access-control.html#policies"
  },"9": {
    "doc": "Access Control",
    "title": "Detailed example",
    "content": "Here is a detailed example of an example access control section: . access_control: default_policy: deny networks: - name: internal networks: - 10.10.0.0/16 - 192.168.2.0/24 - name: VPN networks: 10.9.0.0/16 rules: - domain: public.example.com policy: bypass - domain: \"*.example.com\" policy: bypass methods: - OPTIONS - domain: secure.example.com policy: one_factor networks: - internal - VPN - 192.168.1.0/24 - 10.0.0.1 - domain: - secure.example.com - private.example.com policy: two_factor - domain: singlefactor.example.com policy: one_factor - domain: \"mx2.mail.example.com\" subject: \"group:admins\" policy: deny - domain: \"*.example.com\" subject: - \"group:admins\" - \"group:moderators\" policy: two_factor - domain: dev.example.com resources: - \"^/groups/dev/.*$\" subject: \"group:dev\" policy: two_factor - domain: dev.example.com resources: - \"^/users/john/.*$\" subject: - [\"group:dev\", \"user:john\"] - \"group:admins\" policy: two_factor - domain: \"{user}.example.com\" policy: bypass . ",
    "url": "/docs/configuration/access-control.html#detailed-example",
    "relUrl": "/configuration/access-control.html#detailed-example"
  },"10": {
    "doc": "Miscellaneous Additional Resources",
    "title": "Articles",
    "content": "Setting Up Authelia With SWAG Authelia Tutorial – Protect your Docker Traefik stack with Private MFA . ",
    "url": "/docs/community/additional-resources.html#articles",
    "relUrl": "/community/additional-resources.html#articles"
  },"11": {
    "doc": "Miscellaneous Additional Resources",
    "title": "Youtube Videos",
    "content": "Authelia: Install Guide on Unraid + NGINX (Deep Dive) . ",
    "url": "/docs/community/additional-resources.html#youtube-videos",
    "relUrl": "/community/additional-resources.html#youtube-videos"
  },"12": {
    "doc": "Miscellaneous Additional Resources",
    "title": "Miscellaneous Additional Resources",
    "content": "In this document you will find miscellaneous resources that could give you more information on Authelia or help you set it up. ",
    "url": "/docs/community/additional-resources.html",
    "relUrl": "/community/additional-resources.html"
  },"13": {
    "doc": "Architecture",
    "title": "Architecture",
    "content": "Authelia is a companion of reverse proxies like Nginx, Traefik and HAProxy. It can be seen as an extension of those proxies providing authentication functions and a login portal. As shown in the following architecture diagram, Authelia is directly connected to the reverse proxy but never directly connected to application backends and therefore the payloads sent by the clients of the protected API will never reach Authelia, only the authentication pieces will, like the Authorization header for instance. Consequently, the protected APIs can be a REST, a GraphQL or any other kind of API on top of HTTP. ",
    "url": "/docs/home/architecture.html",
    "relUrl": "/home/architecture.html"
  },"14": {
    "doc": "Architecture",
    "title": "Workflow",
    "content": "Reverse proxies are configured so that every incoming request generates an authentication request sent to Authelia. Authelia responds and will instruct the reverse proxy to either allow the incoming request to pass through, or block it because the user is not authenticated or is not sufficiently authorized. Step by step . When the first request of an unauthenticated user hits the reverse proxy, Authelia determines the user is not authenticated because no session cookie has been sent along with the request. Consequently, Authelia redirects the user to the authentication portal provided by Authelia itself. The user can then execute the authentication workflow using that portal to obtain a session cookie valid for all subdomains of the domain protected by Authelia. When the user visits the initial website again, the query is sent along with the session cookie which is forwarded in the authentication request to Authelia. This time, Authelia can verify the user is authenticated and order the reverse proxy to let the query pass through. Sequence Diagram . Here is a description of the complete workflow: . ",
    "url": "/docs/home/architecture.html#workflow",
    "relUrl": "/home/architecture.html#workflow"
  },"15": {
    "doc": "Architecture",
    "title": "HTTP/HTTPS",
    "content": "Authelia only works for websites served over HTTPS because the session cookie can only be transmitted over secure connections. Please note that it has been decided that we won’t support websites served over HTTP in order to avoid any risk due to misconfiguration. (see #590). If a self-signed certificate is required, the following command can be used to generate one: . # Generate a certificate covering \"example.com\" for one year in the /tmp/certs/ directory. $ docker run authelia/authelia authelia certificates generate --host example.com --dir /tmp/certs/ . ",
    "url": "/docs/home/architecture.html#httphttps",
    "relUrl": "/home/architecture.html#httphttps"
  },"16": {
    "doc": "Authelia Scripts",
    "title": "Authelia Scripts",
    "content": "Authelia comes with a set of dedicated scripts to perform a broad range of operations such as building the distributed version of Authelia, building the Docker image, running suites, testing the code, etc… . Those scripts become available after sourcing the bootstrap.sh script with . $ source bootstrap.sh . Then, you can access the scripts usage by running the following command: . $ authelia-scripts --help . For instance, you can build Authelia (Go binary and frontend) with: . $ authelia-scripts build . Or build the official Docker image with: . $ authelia-scripts docker build . Or start the Standalone suite with: . $ authelia-scripts suites setup Standalone . You will find more information in the scripts usage helpers. ",
    "url": "/docs/contributing/authelia-scripts.html",
    "relUrl": "/contributing/authelia-scripts.html"
  },"17": {
    "doc": "Build & Dev",
    "title": "Build &amp; Dev",
    "content": "Authelia is written in Go and comes with a dedicated CLI called authelia-scripts which is available after running source bootstrap.sh. This CLI provides many useful tools to help you during development. In order to build and contribute to Authelia, you need to make sure Go &gt;= v1.16, Docker, docker-compose and Node &gt;= v12 are installed on your machine. ",
    "url": "/docs/contributing/build-and-dev.html#build--dev",
    "relUrl": "/contributing/build-and-dev.html#build--dev"
  },"18": {
    "doc": "Build & Dev",
    "title": "Get started",
    "content": "Authelia is made of Go application serving the API and a React application for the portal. In order to ease development, Authelia uses the concept of suites to run Authelia from source code so that your patches are included. This is a kind of virtual environment running Authelia in a complete ecosystem (LDAP, Redis, SQL server). Note that Authelia is hot-reloaded in the environment so that your patches are instantly included. The next command starts the suite called Standalone: . $ authelia-scripts suites setup Standalone . Most of the suites are using docker-compose to bootstrap the environment. Therefore, you can check the logs of all application by running the following command on the component you want to monitor. $ docker logs authelia_authelia-backend_1 -f . Then, edit the code and observe how Authelia is automatically reloaded. Unit tests . To run the unit tests, run: . $ authelia-scripts unittest . Integration tests . Integration tests are located under the internal/suites directory and are based on Selenium. A suite is a combination of environment and tests. Executing a suite therefore means starting the environment, running the tests and tearing down the environment. Each step can be run independently: . # List the available suites $ authelia-scripts suites list Standalone DuoPush LDAP Traefik # Start the environment of Standalone suite. $ authelia-scripts suites setup Standalone # Run the tests related to the currently running suite. $ authelia-scripts suites test # Tear down the environment $ authelia-scripts suites teardown Standalone . In order to test all suites (approx 30 minutes), you need to make sure there is no currently running suite and then you should run: . $ authelia-scripts suites test . Also, you don’t need to start the suite before testing it. Given you’re not running any suite, just use the following command to test the Standalone suite. $ authelia-scripts suites test Standalone . The suite will be spawned, tests will be run and then the suite will be torn down automatically. ",
    "url": "/docs/contributing/build-and-dev.html#get-started",
    "relUrl": "/contributing/build-and-dev.html#get-started"
  },"19": {
    "doc": "Build & Dev",
    "title": "Build & Dev",
    "content": " ",
    "url": "/docs/contributing/build-and-dev.html",
    "relUrl": "/contributing/build-and-dev.html"
  },"20": {
    "doc": "Commit Message Guidelines",
    "title": "Commit Message Guidelines",
    "content": " ",
    "url": "/docs/contributing/commitmsg-guidelines.html",
    "relUrl": "/contributing/commitmsg-guidelines.html"
  },"21": {
    "doc": "Commit Message Guidelines",
    "title": "The reasons for these conventions:",
    "content": ". | simple navigation though and easier to read git history | . ",
    "url": "/docs/contributing/commitmsg-guidelines.html#the-reasons-for-these-conventions",
    "relUrl": "/contributing/commitmsg-guidelines.html#the-reasons-for-these-conventions"
  },"22": {
    "doc": "Commit Message Guidelines",
    "title": "Format of the commit message:",
    "content": "Each commit message consists of a header, a body, and a footer. &lt;header&gt; &lt;BLANK LINE&gt; &lt;body&gt; &lt;BLANK LINE&gt; &lt;footer&gt; . The header is mandatory and must conform to the Commit Message Header format. The header cannot be longer than 72 characters. The body is mandatory for all commits except for those of type “docs”. When the body is present it must be at least 20 characters long and must conform to the Commit Message Body format. The footer is optional. The Commit Message Footer format describes what the footer is used for, and the structure it must have. Commit Message Header . &lt;type&gt;(&lt;scope&gt;): &lt;summary&gt; │ │ │ │ │ └─⫸ Summary in present tense. Not capitalized. No period at the end. │ │ │ └─⫸ Commit Scope: api|authentication|authorization|cmd|commands|configuration|duo| │ handlers|logging|middlewares|mocks|models|notification|oidc| │ regulation|server|session|storage|suites|templates|utils|web │ └─⫸ Commit Type: build|ci|docs|feat|fix|perf|refactor|release|test . The &lt;type&gt; and &lt;summary&gt; fields are mandatory, the (&lt;scope&gt;) field is optional. Allowed &lt;type&gt; values: . | build Changes that affect the build system or external dependencies (example scopes: bundler, deps, docker, go, npm) | ci Changes to our CI configuration files and scripts (example scopes: autheliabot, buildkite, codecov, golangci-lint, renovate, reviewdog) | docs Documentation only changes | feat A new feature | fix A bug fix | perf A code change that improves performance | refactor A code change that neither fixes a bug nor adds a feature | release Releasing a new version of Authelia | test Adding missing tests or correcting existing tests | . Allowed &lt;scope&gt; values: . The scope should be the name of the package affected (as perceived by the person reading the changelog generated from commit messages). | authentication | authorization | commands | configuration | duo | handlers | logging | middlewares | mocks | models | notification | oidc | regulation | server | session | storage | suites | templates | totp | utils | . There are currently a few exceptions to the “use package name” rule: . | api: used for changes that change the openapi specification . | cmd: used for changes to the authelia|authelia-scripts|authelia-suites top level binaries . | web: used for changes to the React based frontend . | none/empty string: useful for test, refactor and changes that are done across multiple packages (e.g. test: add missing unit tests) and for docs changes that are not related to a specific package (e.g. docs: fix typo in tutorial). | . Summary . Use the summary field to provide a succinct description of the change: . | use the imperative, present tense: “change” not “changed” nor “changes” | don’t capitalize the first letter | no dot (.) at the end | . Commit Message Body . Just as in the summary, use the imperative, present tense: “fix” not “fixed” nor “fixes”. Explain the motivation for the change in the commit message body. This commit message should explain why you are making the change. You can include a comparison of the previous behavior with the new behavior in order to illustrate the impact of the change. Commit Message Footer . The footer can contain information about breaking changes and is also the place to reference GitHub issues and other PRs that this commit closes or is related to. BREAKING CHANGE: &lt;breaking change summary&gt; &lt;BLANK LINE&gt; &lt;breaking change description + migration instructions&gt; &lt;BLANK LINE&gt; &lt;BLANK LINE&gt; Fixes #&lt;issue number&gt; . Breaking Change section should start with the phrase “BREAKING CHANGE: “ followed by a summary of the breaking change, a blank line, and a detailed description of the breaking change that also includes migration instructions. Revert commits . If the commit reverts a previous commit, it should begin with revert: , followed by the header of the reverted commit. The content of the commit message body should contain: . | information about the SHA of the commit being reverted in the following format: This reverts commit &lt;SHA&gt;, | a clear description of the reason for reverting the commit message. | . ",
    "url": "/docs/contributing/commitmsg-guidelines.html#format-of-the-commit-message",
    "relUrl": "/contributing/commitmsg-guidelines.html#format-of-the-commit-message"
  },"23": {
    "doc": "Commit Message Guidelines",
    "title": "Example commit message:",
    "content": "fix(logging): disabled colored logging outputs when file is specified In some scenarios if a user has a log_file_path specified and a TTY seems to be detected this causes terminal coloring outputs to be written to the file. This in turn will cause issues when attempting to utilise the log with the provided fail2ban regexes. We now override any TTY detection/logging treatments and disable coloring/removal of the timestamp when a user is utilising the text based logger to a file. Fixes #1480. This document is based on AngularJS Git Commit Message Format. ",
    "url": "/docs/contributing/commitmsg-guidelines.html#example-commit-message",
    "relUrl": "/contributing/commitmsg-guidelines.html#example-commit-message"
  },"24": {
    "doc": "Deployment - Highly-Available",
    "title": "Highly-Available Deployment",
    "content": "Authelia can be deployed on bare metal or on Kubernetes with two different kind of artifacts: the distributable version (binary and public_html) or a Docker image. NOTE: If not done already, we highly recommend you first follow the Getting Started documentation. ",
    "url": "/docs/deployment/deployment-ha.html#highly-available-deployment",
    "relUrl": "/deployment/deployment-ha.html#highly-available-deployment"
  },"25": {
    "doc": "Deployment - Highly-Available",
    "title": "On Bare Metal",
    "content": "Authelia has been designed to be a proxy companion handling the authentication and authorization requests for your entire infrastructure. As Authelia will be key to your architecture, it requires several components to make it highly-available. Deploying it in production means having an LDAP server for storing the information about the users, a Redis cache to store the user sessions in a distributed manner, a SQL server like MariaDB to persist user configurations and one or more nginx reverse proxies configured to be used with Authelia. With such a setup Authelia can easily be scaled to multiple instances to evenly handle the traffic. Here are the available steps to deploy Authelia given the configuration file is /path/to/your/configuration.yml. Note that you can create your own configuration file from config.template.yml located at the root of the repo. NOTE: Prefer using environment variables to set secrets in production otherwise pay attention to the permissions of the configuration file. See secrets for more information. Deploy with the distributable version . # Build it if not done already $ authelia-scripts build $ authelia --config /path/to/your/configuration.yml . Deploy With Docker . $ docker run -v /path/to/your/configuration.yml:/config/configuration.yml -e TZ=Europe/Paris authelia/authelia . ",
    "url": "/docs/deployment/deployment-ha.html#on-bare-metal",
    "relUrl": "/deployment/deployment-ha.html#on-bare-metal"
  },"26": {
    "doc": "Deployment - Highly-Available",
    "title": "FAQ",
    "content": "Why is this not automated? . Ansible would be a very good candidate to automate the installation of such an infrastructure on bare metal. We would be more than happy to review any PR on that matter. ",
    "url": "/docs/deployment/deployment-ha.html#faq",
    "relUrl": "/deployment/deployment-ha.html#faq"
  },"27": {
    "doc": "Deployment - Highly-Available",
    "title": "Deployment - Highly-Available",
    "content": " ",
    "url": "/docs/deployment/deployment-ha.html",
    "relUrl": "/deployment/deployment-ha.html"
  },"28": {
    "doc": "Deployment - Kubernetes",
    "title": "Deployment on Kubernetes",
    "content": ". ",
    "url": "/docs/deployment/deployment-kubernetes.html#deployment-on-kubernetes",
    "relUrl": "/deployment/deployment-kubernetes.html#deployment-on-kubernetes"
  },"29": {
    "doc": "Deployment - Kubernetes",
    "title": "UNDER CONSTRUCTION",
    "content": "The following areas are actively being worked on for Kubernetes: . | Detailed Documentaiton | Helm Chart (v3) | Kustomize Deployment | Manifest Examples | . Users are welcome to reach out directly by using any of our various contact options. ",
    "url": "/docs/deployment/deployment-kubernetes.html#under-construction",
    "relUrl": "/deployment/deployment-kubernetes.html#under-construction"
  },"30": {
    "doc": "Deployment - Kubernetes",
    "title": "FAQ",
    "content": "RAM usage . If using file-based authentication, the argon2id provider will by default use 1GB of RAM for password generation. This means you should allow for at least this amount in your deployment/daemonset spec and have this much available on your node, alternatively you can tweak the providers settings. Otherwise, your Authelia may OOM during login. See here for more info. ",
    "url": "/docs/deployment/deployment-kubernetes.html#faq",
    "relUrl": "/deployment/deployment-kubernetes.html#faq"
  },"31": {
    "doc": "Deployment - Kubernetes",
    "title": "Deployment - Kubernetes",
    "content": " ",
    "url": "/docs/deployment/deployment-kubernetes.html",
    "relUrl": "/deployment/deployment-kubernetes.html"
  },"32": {
    "doc": "Deployment - Lite",
    "title": "Lite Deployment",
    "content": "Authelia can be deployed as a lite setup with minimal external dependencies. The setup is called lite because it reduces the number of components in the architecture to a reverse proxy such as Nginx, Traefik or HAProxy, Authelia and Redis. This setup assumes you have basic knowledge and understanding of IP addresses, DNS and port forwarding. You should setup the domain you intend to protect with Authelia to point to your external IP address and port forward ports 80 and 443 to the host you plan to host the docker-compose.yml bundle. Port 80 is utilised by LetsEncrypt for certificate challenges, this will automatically provision up-to-date certificates for your domain(s). Traefik publishes the respective services with LetsEncrypt provided certificates on port 443. The provided examples protect the Traefik dashboard with Authelia’s one-factor auth (traefik.example.com) and two instances of the whoami container with Authelia being bypassed (public.example.com) and another with it’s two-factor auth (secure.example.com). If you happen to already have an external SQL instance (MariaDB, MySQL or Postgres) this setup can easily be adapted to utilise said service. ",
    "url": "/docs/deployment/deployment-lite.html#lite-deployment",
    "relUrl": "/deployment/deployment-lite.html#lite-deployment"
  },"33": {
    "doc": "Deployment - Lite",
    "title": "Steps",
    "content": ". | git clone https://github.com/authelia/authelia.git | cd authelia/examples/compose/lite | git checkout $(git describe --tags `git rev-list --tags --max-count=1`) | Modify the users_database.yml the default username and password is authelia | Modify the configuration.yml and docker-compose.yml with your respective domains and secrets | docker-compose up -d | . ",
    "url": "/docs/deployment/deployment-lite.html#steps",
    "relUrl": "/deployment/deployment-lite.html#steps"
  },"34": {
    "doc": "Deployment - Lite",
    "title": "Reverse Proxy",
    "content": "The Lite bundle provides pre-made examples with Traefik2.x, you can swap this out for any of the supported proxies. ",
    "url": "/docs/deployment/deployment-lite.html#reverse-proxy",
    "relUrl": "/deployment/deployment-lite.html#reverse-proxy"
  },"35": {
    "doc": "Deployment - Lite",
    "title": "FAQ",
    "content": "Can you give more details on why this is not suitable for production environments? . This documentation gives instructions that will make Authelia non resilient to failures and non scalable by preventing you from running multiple instances of the application. This means that Authelia won’t be able to distribute the load across multiple servers and it will prevent failover in case of a crash or an hardware issue. ",
    "url": "/docs/deployment/deployment-lite.html#faq",
    "relUrl": "/deployment/deployment-lite.html#faq"
  },"36": {
    "doc": "Deployment - Lite",
    "title": "Deployment - Lite",
    "content": " ",
    "url": "/docs/deployment/deployment-lite.html",
    "relUrl": "/deployment/deployment-lite.html"
  },"37": {
    "doc": "Duo Push Notifications",
    "title": "Duo Push Notifications",
    "content": "Authelia supports mobile push notifications relying on Duo. Follow the instructions in the dedicated documentation to know how to set up push notifications in Authelia. Note: The configuration options in the following sections are noted as required. They are however only required when you have this section defined. i.e. if you don’t wish to use the Duo push notifications you can just not define this section of the configuration. ",
    "url": "/docs/configuration/duo-push-notifications.html",
    "relUrl": "/configuration/duo-push-notifications.html"
  },"38": {
    "doc": "Duo Push Notifications",
    "title": "Configuration",
    "content": "The configuration is as follows: . duo_api: hostname: api-123456789.example.com integration_key: ABCDEF secret_key: 1234567890abcdefghifjkl enable_self_enrollment: false . The secret key is shown as an example, you also have the option to set it using an environment variable as described here. ",
    "url": "/docs/configuration/duo-push-notifications.html#configuration",
    "relUrl": "/configuration/duo-push-notifications.html#configuration"
  },"39": {
    "doc": "Duo Push Notifications",
    "title": "Options",
    "content": "hostname . type: string . default: “” . required: yes . The Duo API hostname supplied by Duo. integration_key . type: string . default: “” . required: yes . The non-secret Duo integration key. Similar to a client identifier. secret_key . type: string . default: “” . required: yes . The secret Duo key used to verify your application is valid. enable_self_enrollment . type: boolean . default: false . required: no . Enables Duo device self-enrollment from within the Authelia portal. ",
    "url": "/docs/configuration/duo-push-notifications.html#options",
    "relUrl": "/configuration/duo-push-notifications.html#options"
  },"40": {
    "doc": "Example of authelia lite on docker swarm",
    "title": "Example of authelia lite on docker swarm",
    "content": "The overlay network for docker swarm can be initialized with: . $ docker swarm init $ docker swarm init &amp;&amp; docker network create --driver=overlay traefik-public $ mkdir ./redis ./letsencrypt . The structure of the folder should be like this: . ├── authelia/ │   ├── configuration.yml │   └── users_database.yml ├── redis/ ├── letsencrypt/ │   └── acme.json └── traefik-compose.yml . The following configuration allows you to deploy authelia to docker swarm with traefik 2.x. Please replace the example.com and your@email.com with your domain and email respectively. Then save it as traefik-compose.yml. version: '3.3' services: authelia: image: authelia/authelia:4 volumes: - ./authelia:/config networks: - traefik-public deploy: labels: - 'traefik.enable=true' - 'traefik.http.routers.authelia.rule=Host(`auth.example.com`)' - 'traefik.http.routers.authelia.entrypoints=web' - \"traefik.http.services.authelia.loadbalancer.server.port=9091\" # TLS - \"traefik.http.routers.authelias.rule=Host(`auth.example.com`)\" - \"traefik.http.routers.authelias.entrypoints=websecure\" - \"traefik.http.routers.authelias.tls.certresolver=letsencrypt\" # Redirect - \"traefik.http.routers.authelia.middlewares=https_redirect\" - \"traefik.http.middlewares.https_redirect.redirectscheme.scheme=https\" # Authelia - 'traefik.http.middlewares.authelia.forwardauth.address=http://authelia:9091/api/verify?rd=https://auth.example.com' - 'traefik.http.middlewares.authelia.forwardauth.trustForwardHeader=true' - 'traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User, Remote-Groups' - \"traefik.http.routers.authelia.service=authelia\" redis: image: redis:6-alpine volumes: - ./redis:/data networks: - traefik-public traefik: # The official v2.0 Traefik docker image image: traefik:v2.2 deploy: labels: - 'traefik.enable=true' - 'traefik.http.routers.api.rule=Host(`traefik.example.com`)' - 'traefik.http.routers.api.entrypoints=web' - 'traefik.http.routers.api.service=api@internal' - 'traefik.http.services.traefik.loadbalancer.server.port=80' # TLS - \"traefik.http.routers.apis.rule=Host(`traefik.example.com`)\" - \"traefik.http.routers.apis.entrypoints=websecure\" - \"traefik.http.routers.apis.tls.certresolver=letsencrypt\" # Redirect - \"traefik.http.routers.api.middlewares=https_redirect\" - \"traefik.http.middlewares.https_redirect.redirectscheme.scheme=https\" # Authelia - 'traefik.http.routers.apis.service=api@internal' - 'traefik.http.routers.apis.middlewares=authelia@docker' placement: constraints: - node.role == manager command: - \"--api\" - \"--providers.docker=true\" - \"--providers.docker.swarmMode=true\" - \"--providers.docker.exposedbydefault=false\" - \"--entrypoints.web.address=:80\" - \"--entryPoints.websecure.address=:443\" - \"--certificatesresolvers.letsencrypt.acme.httpchallenge=true\" - \"--certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web\" - \"--certificatesresolvers.letsencrypt.acme.email=your@email.com\" - \"--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json\" ports: # Listen on port 80, default for HTTP, necessary to redirect to HTTPS - target: 80 published: 80 mode: host # Listen on port 443, default for HTTPS - target: 443 published: 443 mode: host volumes: # So that Traefik can listen to the Docker events - /var/run/docker.sock:/var/run/docker.sock - ./letsencrypt:/letsencrypt networks: - traefik-public secure: image: containous/whoami networks: - traefik-public deploy: labels: - 'traefik.enable=true' - 'traefik.http.routers.secure.rule=Host(`secure.example.com`)' - 'traefik.http.routers.secure.entrypoints=web' - 'traefik.http.services.secure.loadbalancer.server.port=80' # TLS - \"traefik.http.routers.secures.rule=Host(`secure.example.com`)\" - \"traefik.http.routers.secures.entrypoints=websecure\" - \"traefik.http.routers.secures.tls.certresolver=letsencrypt\" # Redirect - \"traefik.http.routers.secure.middlewares=https_redirect\" - \"traefik.http.middlewares.https_redirect.redirectscheme.scheme=https\" # Authelia - 'traefik.http.routers.secures.middlewares=authelia@docker' public: image: containous/whoami networks: - traefik-public deploy: labels: - 'traefik.enable=true' - 'traefik.http.routers.public.rule=Host(`public.example.com`)' - 'traefik.http.routers.public.entrypoints=web' - 'traefik.http.services.public.loadbalancer.server.port=80' # TLS - \"traefik.http.routers.publics.rule=Host(`public.example.com`)\" - \"traefik.http.routers.publics.entrypoints=websecure\" - \"traefik.http.routers.publics.tls.certresolver=letsencrypt\" # Redirect - \"traefik.http.routers.public.middlewares=https_redirect\" - \"traefik.http.middlewares.https_redirect.redirectscheme.scheme=https\" # Authelia - 'traefik.http.routers.publics.middlewares=authelia@docker' networks: traefik-public: external: true . Finally, the stack is ready to be deployed. $ docker stack deploy -c traefik-compose.yml traefik . Full configuration files can be found here https://github.com/wuhanstudio/authelia-docker-swarm . $ docker swarm init &amp;&amp; docker network create --driver=overlay traefik-public $ git clone https://github.com/wuhanstudio/authelia-docker-swarm &amp;&amp; cd authelia-docker-swarm # Replace wuhanstudio.cc with your domain $ find . -type f -name \"*.yml\" -exec sed -i'' -e 's/example.com/wuhanstudio.cc/g' {} + # Replace wuhanstudio@qq.com with your email $ find . -type f -name \"*.yml\" -exec sed -i'' -e 's/your@email.com/wuhanstudio@qq.com/g' {} + $ docker stack deploy -c traefik-compose.yml traefik . ",
    "url": "/docs/community/example-of-authelia-lite-on-docker-swarm.html",
    "relUrl": "/community/example-of-authelia-lite-on-docker-swarm.html"
  },"41": {
    "doc": "FAQ",
    "title": "Frequently asked questions",
    "content": " ",
    "url": "/docs/faq.html#frequently-asked-questions",
    "relUrl": "/faq.html#frequently-asked-questions"
  },"42": {
    "doc": "FAQ",
    "title": "How can the backend be aware of the authenticated users?",
    "content": "This question is solved here. ",
    "url": "/docs/faq.html#how-can-the-backend-be-aware-of-the-authenticated-users",
    "relUrl": "/faq.html#how-can-the-backend-be-aware-of-the-authenticated-users"
  },"43": {
    "doc": "FAQ",
    "title": "Why only use a private issuer key and no public key with OIDC?",
    "content": "The reason for using only the private key here is that one is able to calculate the public key easily from the private key (openssl rsa -in rsa.key -pubout &gt; rsa.pem). ",
    "url": "/docs/faq.html#why-only-use-a-private-issuer-key-and-no-public-key-with-oidc",
    "relUrl": "/faq.html#why-only-use-a-private-issuer-key-and-no-public-key-with-oidc"
  },"44": {
    "doc": "FAQ",
    "title": "FAQ",
    "content": " ",
    "url": "/docs/faq.html",
    "relUrl": "/faq.html"
  },"45": {
    "doc": "File",
    "title": "File",
    "content": "Authelia supports a file as a users database. ",
    "url": "/docs/configuration/authentication/file.html",
    "relUrl": "/configuration/authentication/file.html"
  },"46": {
    "doc": "File",
    "title": "Configuration",
    "content": "Configuring Authelia to use a file is done by specifying the path to the file in the configuration file. authentication_backend: disable_reset_password: false file: path: /config/users.yml password: algorithm: argon2id iterations: 1 salt_length: 16 parallelism: 8 memory: 64 . ",
    "url": "/docs/configuration/authentication/file.html#configuration",
    "relUrl": "/configuration/authentication/file.html#configuration"
  },"47": {
    "doc": "File",
    "title": "Format",
    "content": "The format of the users file is as follows. users: john: displayname: \"John Doe\" password: \"$argon2id$v=19$m=65536,t=3,p=2$BpLnfgDsc2WD8F2q$o/vzA4myCqZZ36bUGsDY//8mKUYNZZaR0t4MFFSs+iM\" email: john.doe@authelia.com groups: - admins - dev harry: displayname: \"Harry Potter\" password: \"$argon2id$v=19$m=65536,t=3,p=2$BpLnfgDsc2WD8F2q$o/vzA4myCqZZ36bUGsDY//8mKUYNZZaR0t4MFFSs+iM\" email: harry.potter@authelia.com groups: [] bob: displayname: \"Bob Dylan\" password: \"$argon2id$v=19$m=65536,t=3,p=2$BpLnfgDsc2WD8F2q$o/vzA4myCqZZ36bUGsDY//8mKUYNZZaR0t4MFFSs+iM\" email: bob.dylan@authelia.com groups: - dev james: displayname: \"James Dean\" password: \"$argon2id$v=19$m=65536,t=3,p=2$BpLnfgDsc2WD8F2q$o/vzA4myCqZZ36bUGsDY//8mKUYNZZaR0t4MFFSs+iM\" email: james.dean@authelia.com . This file should be set with read/write permissions as it could be updated by users resetting their passwords. ",
    "url": "/docs/configuration/authentication/file.html#format",
    "relUrl": "/configuration/authentication/file.html#format"
  },"48": {
    "doc": "File",
    "title": "Options",
    "content": "path . type: string (path) . required: yes . password . algorithm . type: string . default: argon2id . required: no . Controls the hashing algorithm used for hashing new passwords. Value must be one of argon2id or `sha512. iterations . type: integer . required: no . Controls the number of hashing iterations done by the other hashing settings. When using argon2id the minimum is 1, which is also the recommended value. When using sha512 the minimum is 1000, and 50000 is the recommended value. salt_length . type: integer . default: 16 . required: no . Controls the length of the random salt added to each password before hashing. It’s recommended this value is set to 16, and there is no documented reason why you’d set it to anything other than this, however the minimum is 8. parallelism . type: integer . default: 8 . required: no . This setting is specific to argon2id and unused with sha512. Sets the number of threads used when hashing passwords, which affects the effective cost of hashing. memory . This setting is specific to argon2id and unused with sha512. Sets the amount of memory allocated to a single password hashing action. This memory is released by go after the hashing process completes, however the operating system may not reclaim it until it needs the memory which may make Authelia appear to be using more memory than it technically is. ",
    "url": "/docs/configuration/authentication/file.html#options",
    "relUrl": "/configuration/authentication/file.html#options"
  },"49": {
    "doc": "File",
    "title": "Passwords",
    "content": "The file contains hashed passwords instead of plain text passwords for security reasons. You can use Authelia binary or docker image to generate the hash of any password. The hash-password command has many tunable options, you can view them with the authelia hash-password --help command. For example if you wanted to improve the entropy you could generate a 16 byte salt and provide it with the --salt flag. Example: authelia hash-password --salt abcdefghijklhijl. For argon2id the salt must always be valid for base64 decoding (characters a through z, A through Z, 0 through 9, and +/). Passwords passed to hash-password should be single quoted if using special characters to prevent parameter substitution. For instance to generate a hash with the docker image just run: . $ docker run authelia/authelia:latest authelia hash-password 'yourpassword' Password hash: $argon2id$v=19$m=65536$3oc26byQuSkQqksq$zM1QiTvVPrMfV6BVLs2t4gM+af5IN7euO0VB6+Q8ZFs . You may also use the --config flag to point to your existing configuration. When used, the values defined in the config will be used instead. Full CLI Help Documentation: . Hash a password to be used in file-based users database. Default algorithm is argon2id. Usage: authelia hash-password [password] [flags] Flags: -h, --help help for hash-password -i, --iterations int set the number of hashing iterations (default 1) -k, --key-length int [argon2id] set the key length param (default 32) -m, --memory int [argon2id] set the amount of memory param (in MB) (default 64) -p, --parallelism int [argon2id] set the parallelism param (default 8) -s, --salt string set the salt string -l, --salt-length int set the auto-generated salt length (default 16) -z, --sha512 use sha512 as the algorithm (defaults iterations to 50000, change with -i) . Password hash algorithm . The default hash algorithm is Argon2id version 19 with a salt. Argon2id is currently considered the best hashing algorithm, and in 2015 won the Password Hashing Competition. It benefits from customizable parameters allowing the cost of computing a hash to scale into the future which makes it harder to brute-force. Argon2id was implemented due to community feedback as you can see in this closed issue. For backwards compatibility and user choice support for the SHA512 algorithm is still available. While it’s a reasonable hashing function given high enough iterations, as hardware improves it has a higher chance of being brute-forced. Hashes are identifiable as argon2id or SHA512 by their prefix of either $argon2id$ and $6$ respectively, as described in this wiki page. Important Note: When using argon2id Authelia will appear to remain using the memory allocated to creating the hash. This is due to how Go allocates memory to the heap when generating an argon2id hash. Go periodically garbage collects the heap, however this doesn’t remove the memory allocation, it keeps it allocated even though it’s technically unused. Under memory pressure the unused allocated memory will be reclaimed by the operating system, you can test this on linux with: . $ stress-ng --vm-bytes $(awk '/MemFree/{printf \"%d\\n\", $2 * 0.9;}' &lt; /proc/meminfo)k --vm-keep -m 1 . If this is not desirable we recommend investigating the following options in order of most to least secure: . | using the LDAP authentication provider | adjusting the memory parameter | changing the algorithm | . Password hash algorithm tuning . All algorithm tuning for Argon2id is supported. The only configuration variables that affect SHA512 are iterations and salt length. The configuration variables are unique to the file authentication provider, thus they all exist in a key under the file authentication configuration key called password. We have set what are considered as sane and recommended defaults to cater for a reasonable system, if you’re unsure about which settings to tune, please see the parameters below, or for a more in depth understanding see the referenced documentation in Argon2 links. Examples for specific systems . These examples have been tested against a single system to make sure they roughly take 0.5 seconds each. Your results may vary depending on individual specification and utilization, but they are a good guide to get started. You should however read the linked documents in Argon2 links. | System | Iterations | Parallelism | Memory | . | Raspberry Pi 2 | 1 | 8 | 64 | . | Raspberry Pi 3 | 1 | 8 | 128 | . | Raspberry Pi 4 | 1 | 8 | 128 | . | Intel G5 i5 NUC | 1 | 8 | 1024 | . ",
    "url": "/docs/configuration/authentication/file.html#passwords",
    "relUrl": "/configuration/authentication/file.html#passwords"
  },"50": {
    "doc": "File",
    "title": "Argon2 Links",
    "content": "How to choose the right parameters for Argon2 . Go Documentation . IETF Draft . ",
    "url": "/docs/configuration/authentication/file.html#argon2-links",
    "relUrl": "/configuration/authentication/file.html#argon2-links"
  },"51": {
    "doc": "Filesystem",
    "title": "Filesystem",
    "content": "With this configuration, the message will be sent to a file. This option should only be used for testing purposes. This method will use the plain text email template for readability purposes. ",
    "url": "/docs/configuration/notifier/filesystem.html",
    "relUrl": "/configuration/notifier/filesystem.html"
  },"52": {
    "doc": "Filesystem",
    "title": "Configuration",
    "content": "notifier: disable_startup_check: false filesystem: filename: /config/notification.txt . ",
    "url": "/docs/configuration/notifier/filesystem.html#configuration",
    "relUrl": "/configuration/notifier/filesystem.html#configuration"
  },"53": {
    "doc": "Filesystem",
    "title": "Options",
    "content": "filename . type: string . required: yes . The file to add email text to. If it doesn’t exist it will be created. ",
    "url": "/docs/configuration/notifier/filesystem.html#options",
    "relUrl": "/configuration/notifier/filesystem.html#options"
  },"54": {
    "doc": "First Factor",
    "title": "First Factor",
    "content": "2-Factor authentication is a method in which a user is granted access by presenting two pieces of evidence that she is who she claims to be. Authelia requires usual username and password as a first factor. IMPORTANT: This is currently the only method available as first factor. Using other methods will likely be possible when WebAuthN is implemented . Authelia supports several kind of users databases: . | An LDAP server like OpenLDAP or OpenAM. | An Active Directory. | A YAML file | . ",
    "url": "/docs/features/first-factor.html",
    "relUrl": "/features/first-factor.html"
  },"55": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": " ",
    "url": "/docs/getting-started.html",
    "relUrl": "/getting-started.html"
  },"56": {
    "doc": "Getting Started",
    "title": "Docker Compose",
    "content": "Steps . These commands are to be run sequentially: . | git clone https://github.com/authelia/authelia.git | cd authelia/examples/compose/local | git checkout $(git describe --tags `git rev-list --tags --max-count=1`) | ./setup.sh sudo is required to modify the /etc/hosts file, the user will be prompted for access if not run as root | . You can now visit the following locations; replace example.com with the domain you specified in the setup script: . | https://public.example.com - Bypasses Authelia | https://traefik.example.com - Secured with Authelia one-factor authentication | https://secure.example.com - Secured with Authelia two-factor authentication (see note below) | . You will need to authorize the self-signed certificate upon visiting each domain. To visit https://secure.example.com you will need to register a device for second factor authentication and confirm by clicking on a link sent by email. Since this is a demo with a fake email address, the content of the email will be stored in ./authelia/notification.txt. Upon registering, you can grab this link easily by running the following command: grep -Eo '\"https://.*\" ' ./authelia/notification.txt. ",
    "url": "/docs/getting-started.html#docker-compose",
    "relUrl": "/getting-started.html#docker-compose"
  },"57": {
    "doc": "Getting Started",
    "title": "Deployment",
    "content": "So you’re convinced that Authelia is what you need. You can head to the deployment documentation here. Some recipes have been crafted for helping with the bootstrap of your environment. You can choose between a lite deployment which is deployment advised for a single server setup. However, this setup just does not scale. If you want a full environment that can scale out, use the HA or Kubernetes deployment documentation. ",
    "url": "/docs/getting-started.html#deployment",
    "relUrl": "/getting-started.html#deployment"
  },"58": {
    "doc": "HAProxy",
    "title": "HAProxy",
    "content": "HAProxy is a reverse proxy supported by Authelia. ",
    "url": "/docs/deployment/supported-proxies/haproxy.html",
    "relUrl": "/deployment/supported-proxies/haproxy.html"
  },"59": {
    "doc": "HAProxy",
    "title": "Requirements",
    "content": "You need the following to run Authelia with HAProxy: . | HAProxy 1.8.4+ (2.2.0+ recommended) . | USE_LUA=1 set at compile time | haproxy-lua-http must be available within the Lua path . | A json library within the Lua path (dependency of haproxy-lua-http, usually found as OS package lua-json) | With HAProxy 2.1.3+ you can use the [lua-prepend-path] configuration option to specify the search path. | . | haproxy-auth-request | . | . ",
    "url": "/docs/deployment/supported-proxies/haproxy.html#requirements",
    "relUrl": "/deployment/supported-proxies/haproxy.html#requirements"
  },"60": {
    "doc": "HAProxy",
    "title": "Configuration",
    "content": "Below you will find commented examples of the following configuration: . | Authelia portal | Protected endpoint (Nextcloud) | Protected endpoint with Authorization header for basic authentication (Heimdall) | haproxy-auth-request | . With this configuration you can protect your virtual hosts with Authelia, by following the steps below: . | Add host(s) to the protected-frontends or protected-frontends-basic ACLs to support protection with Authelia. You can separate each subdomain with a | in the regex, for example: acl protected-frontends hdr(host) -m reg -i ^(?i)(jenkins|nextcloud|phpmyadmin)\\.example\\.com acl protected-frontends-basic hdr(host) -m reg -i ^(?i)(heimdall)\\.example\\.com . | Add host ACL(s) in the form of host-service, this will be utilised to route to the correct backend upon successful authentication, for example: acl host-jenkins hdr(host) -i jenkins.example.com acl host-nextcloud hdr(host) -i nextcloud.example.com acl host-phpmyadmin hdr(host) -i phpmyadmin.example.com acl host-heimdall hdr(host) -i heimdall.example.com . | Add backend route for your service(s), for example: use_backend be_jenkins if host-jenkins use_backend be_nextcloud if host-nextcloud use_backend be_phpmyadmin if host-phpmyadmin use_backend be_heimdall if host-heimdall . | Add backend definitions for your service(s), for example: backend be_jenkins server jenkins jenkins:8080 backend be_nextcloud server nextcloud nextcloud:443 ssl verify none backend be_phpmyadmin server phpmyadmin phpmyadmin:80 backend be_heimdall server heimdall heimdall:443 ssl verify none . | . Secure Authelia with TLS . There is a known limitation with haproxy-auth-request with regard to TLS-enabled backends. If you want to run Authelia TLS enabled the recommended workaround utilises HAProxy itself to proxy the requests. This comes at a cost of two additional TCP connections, but allows the full HAProxy configuration flexibility with regard to TLS verification as well as header rewriting. An example of this configuration is also be provided below. Configuration . haproxy.cfg . global # Path to haproxy-lua-http, below example assumes /usr/local/etc/haproxy/haproxy-lua-http/http.lua lua-prepend-path /usr/local/etc/haproxy/?/http.lua # Path to haproxy-auth-request lua-load /usr/local/etc/haproxy/auth-request.lua log stdout format raw local0 debug defaults mode http log global option httplog option forwardfor frontend fe_http bind *:443 ssl crt /usr/local/etc/haproxy/haproxy.pem # Host ACLs acl protected-frontends hdr(host) -m reg -i ^(?i)(nextcloud)\\.example\\.com acl protected-frontends-basic hdr(host) -m reg -i ^(?i)(heimdall)\\.example\\.com acl host-authelia hdr(host) -i auth.example.com acl host-nextcloud hdr(host) -i nextcloud.example.com acl host-heimdall hdr(host) -i heimdall.example.com # This is required if utilising basic auth with /api/verify?auth=basic http-request set-var(txn.host) hdr(Host) http-request set-var(req.scheme) str(https) if { ssl_fc } http-request set-var(req.scheme) str(http) if !{ ssl_fc } http-request set-var(req.questionmark) str(?) if { query -m found } # These are optional if you wish to use the Methods rule in the access_control section. #http-request set-var(req.method) str(CONNECT) if { method CONNECT } #http-request set-var(req.method) str(GET) if { method GET } #http-request set-var(req.method) str(HEAD) if { method HEAD } #http-request set-var(req.method) str(OPTIONS) if { method OPTIONS } #http-request set-var(req.method) str(POST) if { method POST } #http-request set-var(req.method) str(TRACE) if { method TRACE } #http-request set-var(req.method) str(PUT) if { method PUT } #http-request set-var(req.method) str(PATCH) if { method PATCH } #http-request set-var(req.method) str(DELETE) if { method DELETE } #http-request set-header X-Forwarded-Method %[var(req.method)] # Required headers http-request set-header X-Real-IP %[src] http-request set-header X-Forwarded-Method %[var(req.method)] http-request set-header X-Forwarded-Proto %[var(req.scheme)] http-request set-header X-Forwarded-Host %[req.hdr(Host)] http-request set-header X-Forwarded-Uri %[path]%[var(req.questionmark)]%[query] # Protect endpoints with haproxy-auth-request and Authelia http-request lua.auth-request be_authelia /api/verify if protected-frontends # Force `Authorization` header via query arg to /api/verify http-request lua.auth-request be_authelia /api/verify?auth=basic if protected-frontends-basic # Redirect protected-frontends to Authelia if not authenticated http-request redirect location https://auth.example.com/?rd=%[var(req.scheme)]://%[base]%[var(req.questionmark)]%[query] if protected-frontends !{ var(txn.auth_response_successful) -m bool } # Send 401 and pass `WWW-Authenticate` header on protected-frontend-basic if not pre-authenticated http-request set-var(txn.auth) var(req.auth_response_header.www_authenticate) if protected-frontends-basic !{ var(txn.auth_response_successful) -m bool } http-response deny deny_status 401 hdr WWW-Authenticate %[var(txn.auth)] if { var(txn.host) -m reg -i ^(?i)(heimdall)\\.example\\.com } !{ var(txn.auth_response_successful) -m bool } # Authelia backend route use_backend be_authelia if host-authelia # Service backend route(s) use_backend be_nextcloud if host-nextcloud use_backend be_heimdall if host-heimdall backend be_authelia server authelia authelia:9091 backend be_nextcloud # Pass Remote-User, Remote-Name, Remote-Email and Remote-Groups headers acl remote_user_exist var(req.auth_response_header.remote_user) -m found acl remote_groups_exist var(req.auth_response_header.remote_groups) -m found acl remote_name_exist var(req.auth_response_header.remote_name) -m found acl remote_email_exist var(req.auth_response_header.remote_email) -m found http-request set-header Remote-User %[var(req.auth_response_header.remote_user)] if remote_user_exist http-request set-header Remote-Groups %[var(req.auth_response_header.remote_groups)] if remote_groups_exist http-request set-header Remote-Name %[var(req.auth_response_header.remote_name)] if remote_name_exist http-request set-header Remote-Email %[var(req.auth_response_header.remote_email)] if remote_email_exist server nextcloud nextcloud:443 ssl verify none backend be_heimdall # Pass Remote-User, Remote-Name, Remote-Email and Remote-Groups headers acl remote_user_exist var(req.auth_response_header.remote_user) -m found acl remote_groups_exist var(req.auth_response_header.remote_groups) -m found acl remote_name_exist var(req.auth_response_header.remote_name) -m found acl remote_email_exist var(req.auth_response_header.remote_email) -m found http-request set-header Remote-User %[var(req.auth_response_header.remote_user)] if remote_user_exist http-request set-header Remote-Groups %[var(req.auth_response_header.remote_groups)] if remote_groups_exist http-request set-header Remote-Name %[var(req.auth_response_header.remote_name)] if remote_name_exist http-request set-header Remote-Email %[var(req.auth_response_header.remote_email)] if remote_email_exist server heimdall heimdall:443 ssl verify none . haproxy.cfg (TLS enabled Authelia) . global # Path to haproxy-lua-http, below example assumes /usr/local/etc/haproxy/haproxy-lua-http/http.lua lua-prepend-path /usr/local/etc/haproxy/?/http.lua # Path to haproxy-auth-request lua-load /usr/local/etc/haproxy/auth-request.lua log stdout format raw local0 debug defaults mode http log global option httplog option forwardfor frontend fe_http bind *:443 ssl crt /usr/local/etc/haproxy/haproxy.pem # Host ACLs acl protected-frontends hdr(host) -m reg -i ^(?i)(nextcloud)\\.example\\.com acl protected-frontends-basic hdr(host) -m reg -i ^(?i)(heimdall)\\.example\\.com acl host-authelia hdr(host) -i auth.example.com acl host-nextcloud hdr(host) -i nextcloud.example.com acl host-heimdall hdr(host) -i heimdall.example.com # This is required if utilising basic auth with /api/verify?auth=basic http-request set-var(txn.host) hdr(Host) http-request set-var(req.scheme) str(https) if { ssl_fc } http-request set-var(req.scheme) str(http) if !{ ssl_fc } http-request set-var(req.questionmark) str(?) if { query -m found } # These are optional if you wish to use the Methods rule in the access_control section. #http-request set-var(req.method) str(CONNECT) if { method CONNECT } #http-request set-var(req.method) str(GET) if { method GET } #http-request set-var(req.method) str(HEAD) if { method HEAD } #http-request set-var(req.method) str(OPTIONS) if { method OPTIONS } #http-request set-var(req.method) str(POST) if { method POST } #http-request set-var(req.method) str(TRACE) if { method TRACE } #http-request set-var(req.method) str(PUT) if { method PUT } #http-request set-var(req.method) str(PATCH) if { method PATCH } #http-request set-var(req.method) str(DELETE) if { method DELETE } #http-request set-header X-Forwarded-Method %[var(req.method)] # Required headers http-request set-header X-Real-IP %[src] http-request set-header X-Forwarded-Proto %[var(req.scheme)] http-request set-header X-Forwarded-Host %[req.hdr(Host)] http-request set-header X-Forwarded-Uri %[path]%[var(req.questionmark)]%[query] # Protect endpoints with haproxy-auth-request and Authelia http-request lua.auth-request be_authelia_proxy /api/verify if protected-frontends # Force `Authorization` header via query arg to /api/verify http-request lua.auth-request be_authelia_proxy /api/verify?auth=basic if protected-frontends-basic # Redirect protected-frontends to Authelia if not authenticated http-request redirect location https://auth.example.com/?rd=%[var(req.scheme)]://%[base]%[var(req.questionmark)]%[query] if protected-frontends !{ var(txn.auth_response_successful) -m bool } # Send 401 and pass `WWW-Authenticate` header on protected-frontend-basic if not pre-authenticated http-request set-var(txn.auth) var(req.auth_response_header.www_authenticate) if protected-frontends-basic !{ var(txn.auth_response_successful) -m bool } http-response deny deny_status 401 hdr WWW-Authenticate %[var(txn.auth)] if { var(txn.host) -m reg -i ^(?i)(heimdall)\\.example\\.com } !{ var(txn.auth_response_successful) -m bool } # Authelia backend route use_backend be_authelia if host-authelia # Service backend route(s) use_backend be_nextcloud if host-nextcloud use_backend be_heimdall if host-heimdall backend be_authelia server authelia authelia:9091 backend be_authelia_proxy mode http server proxy 127.0.0.1:9092 listen authelia_proxy mode http bind 127.0.0.1:9092 server authelia authelia:9091 ssl verify none backend be_nextcloud # Pass Remote-User, Remote-Name, Remote-Email and Remote-Groups headers acl remote_user_exist var(req.auth_response_header.remote_user) -m found acl remote_groups_exist var(req.auth_response_header.remote_groups) -m found acl remote_name_exist var(req.auth_response_header.remote_name) -m found acl remote_email_exist var(req.auth_response_header.remote_email) -m found http-request set-header Remote-User %[var(req.auth_response_header.remote_user)] if remote_user_exist http-request set-header Remote-Groups %[var(req.auth_response_header.remote_groups)] if remote_groups_exist http-request set-header Remote-Name %[var(req.auth_response_header.remote_name)] if remote_name_exist http-request set-header Remote-Email %[var(req.auth_response_header.remote_email)] if remote_email_exist server nextcloud nextcloud:443 ssl verify none backend be_heimdall # Pass Remote-User, Remote-Name, Remote-Email and Remote-Groups headers acl remote_user_exist var(req.auth_response_header.remote_user) -m found acl remote_groups_exist var(req.auth_response_header.remote_groups) -m found acl remote_name_exist var(req.auth_response_header.remote_name) -m found acl remote_email_exist var(req.auth_response_header.remote_email) -m found http-request set-header Remote-User %[var(req.auth_response_header.remote_user)] if remote_user_exist http-request set-header Remote-Groups %[var(req.auth_response_header.remote_groups)] if remote_groups_exist http-request set-header Remote-Name %[var(req.auth_response_header.remote_name)] if remote_name_exist http-request set-header Remote-Email %[var(req.auth_response_header.remote_email)] if remote_email_exist server heimdall heimdall:443 ssl verify none . ",
    "url": "/docs/deployment/supported-proxies/haproxy.html#configuration",
    "relUrl": "/deployment/supported-proxies/haproxy.html#configuration"
  },"61": {
    "doc": "Storage Backends",
    "title": "Configuration",
    "content": "storage: encryption_key: a_very_important_secret local: {} mysql: {} postgres: {} . ",
    "url": "/docs/configuration/storage/#configuration",
    "relUrl": "/configuration/storage/#configuration"
  },"62": {
    "doc": "Storage Backends",
    "title": "Options",
    "content": "encryption_key . type: string . required: yes . The encryption key used to encrypt data in the database. It has a minimum length of 20 and must be provided. We encrypt data by creating a sha256 checksum of the provided value, and use that to encrypt the data with the AES-GCM 256bit algorithm. The encrypted data in the database is as follows: . | TOTP Secret | . local . See SQLite. mysql . See MySQL. postgres . See PostgreSQL. ",
    "url": "/docs/configuration/storage/#options",
    "relUrl": "/configuration/storage/#options"
  },"63": {
    "doc": "Storage Backends",
    "title": "Storage Backends",
    "content": "Authelia supports multiple storage backends. The backend is used to store user preferences, 2FA device handles and secrets, authentication logs, etc… . The available storage backends are listed in the table of contents below. ",
    "url": "/docs/configuration/storage/",
    "relUrl": "/configuration/storage/"
  },"64": {
    "doc": "Proxy Integration",
    "title": "Integration with proxies",
    "content": "Authelia works in collaboration with reverse proxies. In the sub-pages you can find the documentation of the configuration required for every supported proxy. If you are not aware of the workflow of an authentication request, reading this documentation first is highly recommended. ",
    "url": "/docs/deployment/supported-proxies/#integration-with-proxies",
    "relUrl": "/deployment/supported-proxies/#integration-with-proxies"
  },"65": {
    "doc": "Proxy Integration",
    "title": "How Authelia integrates with proxies?",
    "content": "Authelia takes authentication requests coming from the proxy and targeting the /api/verify endpoint exposed by Authelia. Two pieces of information are required for Authelia to be able to authenticate the user request: . | The session cookie or a Proxy-Authorization header (see single factor authentication). | The target URL of the user request (used primarily for access control). | . The target URL can be provided using one of the following ways: . | With X-Original-URL header containing the complete URL of the initial request. | With a combination of X-Forwarded-Proto, X-Forwarded-Host and X-Forwarded-URI headers. | . In the case of Traefik, these headers are automatically provided and therefore don’t appear in the configuration examples. ",
    "url": "/docs/deployment/supported-proxies/#how-authelia-integrates-with-proxies",
    "relUrl": "/deployment/supported-proxies/#how-authelia-integrates-with-proxies"
  },"66": {
    "doc": "Proxy Integration",
    "title": "How can the backend be aware of the authenticated users?",
    "content": "The only way Authelia can share information about the authenticated user currently is through the use of four HTTP headers: Remote-User, Remote-Name, Remote-Email and Remote-Groups. Those headers are returned by Authelia on requests to /api/verify and must be forwarded by the reverse proxy to the backends needing them. The headers will be provided with each call to the backend once the user is authenticated. Please note that the backend must support the use of those headers to leverage that information, many backends still don’t (and probably won’t) support it. However, we are working on solving this issue with OpenID Connect/OAuth2 which is a widely adopted open standard for access delegation. So, if you’re developing your own application, you can read those headers and use them. If you don’t own the codebase of the backend, you need to check whether it supports this type of authentication or not. If it does not, you have three options: . | Enable authentication on the backend and make your users authenticate twice (not user-friendly). | Completely disable the authentication of your backend. This works only if all your users share the same privileges in the backend. | Many applications support OAuth2 so the last option would be to just wait for Authelia to be an OpenID Connect provider (https://github.com/authelia/authelia/issues/189). | . ",
    "url": "/docs/deployment/supported-proxies/#how-can-the-backend-be-aware-of-the-authenticated-users",
    "relUrl": "/deployment/supported-proxies/#how-can-the-backend-be-aware-of-the-authenticated-users"
  },"67": {
    "doc": "Proxy Integration",
    "title": "Redirection to the login portal",
    "content": "The endpoint /api/verify has different behaviors depending on whether the rd (for redirection) query parameter is provided. If redirection parameter is provided and contains the URL to the login portal served by Authelia, the request will either generate a 200 response if the request is authenticated or perform a redirection (302 response) to the login portal if not authenticated yet. If no redirection parameter is provided, the response code is either 200 or 401. The redirection must then be handled by the proxy when an error is detected (see nginx example). ",
    "url": "/docs/deployment/supported-proxies/#redirection-to-the-login-portal",
    "relUrl": "/deployment/supported-proxies/#redirection-to-the-login-portal"
  },"68": {
    "doc": "Proxy Integration",
    "title": "Proxy Integration",
    "content": " ",
    "url": "/docs/deployment/supported-proxies/",
    "relUrl": "/deployment/supported-proxies/"
  },"69": {
    "doc": "Security",
    "title": "Security",
    "content": "Authelia takes security very seriously. We follow the rule of responsible disclosure, and we encourage the community to as well. Important: Please see our security policy if you discover a security vulnerability. Our security policy has several methods of contact and more details about the processes we follow. For details about security measures implemented in Authelia, please follow this link and for reading about the threat model follow this link. ",
    "url": "/docs/security/",
    "relUrl": "/security/"
  },"70": {
    "doc": "Deployment",
    "title": "Deployment",
    "content": " ",
    "url": "/docs/deployment/",
    "relUrl": "/deployment/"
  },"71": {
    "doc": "Notifier",
    "title": "Notifier",
    "content": "Authelia sometimes needs to send messages to users in order to verify their identity. ",
    "url": "/docs/configuration/notifier/",
    "relUrl": "/configuration/notifier/"
  },"72": {
    "doc": "Notifier",
    "title": "Configuration",
    "content": "notifier: disable_startup_check: false filesystem: {} smtp: {} . ",
    "url": "/docs/configuration/notifier/#configuration",
    "relUrl": "/configuration/notifier/#configuration"
  },"73": {
    "doc": "Notifier",
    "title": "Options",
    "content": "disable_startup_check . type: boolean . default: false . required: no . The notifier has a startup check which validates the specified provider configuration is correct and will be able to send emails. This can be disabled with the disable_startup_check option: . filesystem . The filesystem provider. smtp . The smtp provider. ",
    "url": "/docs/configuration/notifier/#options",
    "relUrl": "/configuration/notifier/#options"
  },"74": {
    "doc": "Features",
    "title": "Features",
    "content": "Authelia is a 2FA &amp; SSO authentication server which is dedicated to the security of applications and users. It can be considered as an extension of reverse proxies by providing features specific to authentication. You will find among other features: . | Multiple two-factor methods. | Identity verification when registering second factor devices. | Reset password. | Ban account after too many attempts (known as regulation). | . ",
    "url": "/docs/features/",
    "relUrl": "/features/"
  },"75": {
    "doc": "Session",
    "title": "Session",
    "content": "Authelia relies on session cookies to authenticate users. When the user visits a website of the protected domain example.com for the first time, Authelia detects that there is no cookie for that user. Consequently, Authelia redirects the user to the login portal through which the user should authenticate to get a cookie which is valid for *.example.com, meaning all websites of the domain. At the next request, Authelia receives the cookie associated to the authenticated user and can then order the reverse proxy to let the request pass through to the application. ",
    "url": "/docs/configuration/session/",
    "relUrl": "/configuration/session/"
  },"76": {
    "doc": "Session",
    "title": "Configuration",
    "content": "session: name: authelia_session domain: example.com same_site: lax secret: unsecure_session_secret expiration: 1h inactivity: 5m remember_me_duration: 1M . ",
    "url": "/docs/configuration/session/#configuration",
    "relUrl": "/configuration/session/#configuration"
  },"77": {
    "doc": "Session",
    "title": "Providers",
    "content": "There are currently two providers for session storage (three if you count Redis Sentinel as a separate provider): . | Memory (default, stateful, no additional configuration) | Redis (stateless). | Redis Sentinel (stateless, highly available). | . Kubernetes or High Availability . It’s important to note when picking a provider, the stateful providers are not recommended in High Availability scenarios like Kubernetes. Each provider has a note beside it indicating it is stateful or stateless the stateless providers are recommended. ",
    "url": "/docs/configuration/session/#providers",
    "relUrl": "/configuration/session/#providers"
  },"78": {
    "doc": "Session",
    "title": "Options",
    "content": "name . type: string . default: authelia_session . required: no . The name of the session cookie. By default this is set to authelia_session. It’s mostly useful to change this if you are doing development or running multiple instances of Authelia. domain . type: string . required: yes . The domain the cookie is assigned to protect. This must be the same as the domain Authelia is served on or the root of the domain. For example if listening on auth.example.com the cookie should be auth.example.com or example.com. same_site . type: string . default: lax . required: no . Sets the cookies SameSite value. Prior to offering the configuration choice this defaulted to None. The new default is Lax. This option is defined in lower-case. So for example if you want to set it to Strict, the value in configuration needs to be strict. You can read about the SameSite cookie in detail on the MDN. In short setting SameSite to Lax is generally the most desirable option for Authelia. None is not recommended unless you absolutely know what you’re doing and trust all the protected apps. Strict is not going to work in many use cases and we have not tested it in this state but it’s available as an option anyway. secret . type: string . required: yes . The secret key used to encrypt session data in Redis. It’s recommended this is set using a secret. expiration . type: string (duration) . default: 1h . required: no . The time in duration notation format before the cookie expires and the session is destroyed. This is overriden by remember_me_duration when the remember me box is checked. inactivity . type: string (duration) . default: 5m . required: no . The time in duration notation format the user can be inactive for until the session is destroyed. Useful if you want long session timers but don’t want unused devices to be vulnerable. remember_me_duration . type: string (duration) . default: 1M . required: no . The time in duration notation format the cookie expires and the session is destroyed when the remember me box is checked. ",
    "url": "/docs/configuration/session/#options",
    "relUrl": "/configuration/session/#options"
  },"79": {
    "doc": "Session",
    "title": "Security",
    "content": "Configuration of this section has an impact on security. You should read notes in security measures for more information. ",
    "url": "/docs/configuration/session/#security",
    "relUrl": "/configuration/session/#security"
  },"80": {
    "doc": "Session",
    "title": "Loading a password from a secret instead of inside the configuration",
    "content": "Password can also be defined using a secret. ",
    "url": "/docs/configuration/session/#loading-a-password-from-a-secret-instead-of-inside-the-configuration",
    "relUrl": "/configuration/session/#loading-a-password-from-a-secret-instead-of-inside-the-configuration"
  },"81": {
    "doc": "Second Factor",
    "title": "Second Factor",
    "content": "There are multiple supported options for the second factor. | Time-based One-Time passwords with Google Authenticator | Security Keys with tokens like Yubikey. | Push notifications on your mobile using Duo. | . ",
    "url": "/docs/features/2fa/",
    "relUrl": "/features/2fa/"
  },"82": {
    "doc": "Authentication Backends",
    "title": "Authentication Backends",
    "content": "There are two ways to store the users along with their password: . | LDAP: users are stored in remote servers like OpenLDAP, OpenAM or Microsoft Active Directory. | File: users are stored in YAML file with a hashed version of their password. | . ",
    "url": "/docs/configuration/authentication/",
    "relUrl": "/configuration/authentication/"
  },"83": {
    "doc": "Authentication Backends",
    "title": "Configuration",
    "content": "authentication_backend: disable_reset_password: false file: {} ldap: {} . ",
    "url": "/docs/configuration/authentication/#configuration",
    "relUrl": "/configuration/authentication/#configuration"
  },"84": {
    "doc": "Authentication Backends",
    "title": "Options",
    "content": "disable_reset_password . type: boolean . default: false . required: no . This setting controls if users can reset their password from the web frontend or not. file . The file authentication provider. ldap . The LDAP authentication provider. ",
    "url": "/docs/configuration/authentication/#options",
    "relUrl": "/configuration/authentication/#options"
  },"85": {
    "doc": "Identity Providers",
    "title": "Identity Providers",
    "content": "This section covers configuration of the identity server characteristics of Authelia. Currently the only identity server supported is OpenID Connect. ",
    "url": "/docs/configuration/identity-providers/",
    "relUrl": "/configuration/identity-providers/"
  },"86": {
    "doc": "Contributing",
    "title": "Contributing",
    "content": " ",
    "url": "/docs/contributing/",
    "relUrl": "/contributing/"
  },"87": {
    "doc": "Contributing",
    "title": "Development workflow",
    "content": "Authelia and its development workflow can be tested with Docker and docker-compose on Linux. In order to deploy the current version of Authelia locally, run the following command and follow the instructions of bootstrap.sh: . $ source bootstrap.sh . Then, start the Standalone suite. $ authelia-scripts suites setup Standalone . A suite is kind of a virtual environment for running Authelia in a complete ecosystem. If you want more details please read the related documentation. ",
    "url": "/docs/contributing/#development-workflow",
    "relUrl": "/contributing/#development-workflow"
  },"88": {
    "doc": "Contributing",
    "title": "FAQ",
    "content": "What version of Docker and docker-compose should I use? . Here are the versions used for testing in Buildkite: . $ docker --version Docker version 20.10.8, build 3967b7d $ docker-compose --version docker-compose version 1.28.0, build unknown . How can I serve my application under example.com? . Don’t worry, you don’t need to own the domain example.com to test Authelia. Copy the following lines in your /etc/hosts. 192.168.240.100 home.example.com 192.168.240.100 login.example.com 192.168.240.100 singlefactor.example.com 192.168.240.100 public.example.com 192.168.240.100 secure.example.com 192.168.240.100 mail.example.com 192.168.240.100 mx1.mail.example.com . 192.168.240.100 is the IP attributed by Docker to the reverse proxy. Once added you can access the listed sub-domains from your browser, and they will target the reverse proxy. ",
    "url": "/docs/contributing/#faq",
    "relUrl": "/contributing/#faq"
  },"89": {
    "doc": "Home",
    "title": "Home",
    "content": "It has never been so easy to secure your applications with Single Sign-On and Two-Factor. With Authelia you can login once and get access to all your web apps safely from the Web thanks to two-factor authentication. Authelia is an open source authentication and authorization server protecting modern web applications by collaborating with reverse proxies such as NGINX, Traefik and HAProxy. Consequently, no code is required to protect your apps. Multiple 2-factor methods are available for satisfying every users. | Time-based One-Time passwords with Google Authenticator. | Security Keys with tokens like Yubikey. | Push notifications on your mobile using Duo. | . Authelia is available as Docker images, static binaries and AUR packages so that you can test it in minutes. Let’s begin with the Getting Started. ",
    "url": "/docs/",
    "relUrl": "/"
  },"90": {
    "doc": "Home",
    "title": "However, Authelia…",
    "content": ". | OpenID Connect is still in preview. | is not a SAML provider yet. | does not support authentication against an OAuth or OpenID Connect provider yet. | does not support authentication against a SAML provider yet. | does not support using hardware devices as single factor. | does not provide a PAM module yet. | . ",
    "url": "/docs/#however-authelia",
    "relUrl": "/#however-authelia"
  },"91": {
    "doc": "Configuration",
    "title": "Configuration",
    "content": "Authelia has several methods of configuration available to it. The order of precedence is as follows: . | Secrets | Environment Variables | Files (in order of them being specified) | . This order of precedence puts higher weight on things higher in the list. This means anything specified in the files is overridden by environment variables if specified, and anything specified by environment variables is overridden by secrets if specified. ",
    "url": "/docs/configuration/",
    "relUrl": "/configuration/"
  },"92": {
    "doc": "Configuration",
    "title": "Files",
    "content": "When running Authelia, you can specify your configuration by passing the file path as shown below. $ authelia --config config.custom.yml . You can have multiple configuration files which will be merged in the order specified. If duplicate keys are specified the last one to be specified is the one that takes precedence. Example: . $ authelia --config configuration.yml --config config-acl.yml --config config-other.yml $ authelia --config configuration.yml,config-acl.yml,config-other.yml . Authelia’s configuration files use the YAML format. A template with all possible options can be found at the root of the repository here. Docker . By default, the container looks for a configuration file at /config/configuration.yml. This can be changed using the command setting. ",
    "url": "/docs/configuration/#files",
    "relUrl": "/configuration/#files"
  },"93": {
    "doc": "Configuration",
    "title": "Environment",
    "content": "You may also provide the configuration by using environment variables. Environment variables are applied after the configuration file meaning anything specified as part of the environment overrides the configuration files. The environment variables must be prefixed with AUTHELIA_. Please Note: It is not possible to configure the access control rules section or OpenID Connect identity provider section using environment variables at this time. Please Note: There are compatability issues with Kubernetes and this particular configuration option. You must ensure you have the enableServiceLinks: false setting in your pod spec. You can read more about this in the migration documentation. Underscores replace indented configuration sections or subkeys. For example the following environment variables replace the configuration snippet that follows it: . AUTHELIA_LOG_LEVEL=info AUTHELIA_SERVER_READ_BUFFER_SIZE=4096 . log: level: info server: read_buffer_size: 4096 . ",
    "url": "/docs/configuration/#environment",
    "relUrl": "/configuration/#environment"
  },"94": {
    "doc": "Configuration",
    "title": "Documentation",
    "content": "We document the configuration in two ways: . | The configuration yaml default has comments documenting it. All documentation lines start with ##. Lines starting with a single # are yaml configuration options which are commented to disable them or as examples. | This documentation site. Generally each section of the configuration is in its own section of the documentation site. Each configuration option is listed in its relevant section as a heading, under that heading generally are two or three colored labels. | The type label is purple and indicates the yaml value type of the variable. It optionally includes some additional information in parentheses. | The default label is blue and indicates the default value if you don’t define the option at all. This is not the same value as you will see in the examples in all instances, it is the value set when blank or undefined. | The required label changes color. When required it will be red, when not required it will be green, when the required state depends on another configuration value it is yellow. | . | . ",
    "url": "/docs/configuration/#documentation",
    "relUrl": "/configuration/#documentation"
  },"95": {
    "doc": "Configuration",
    "title": "Validation",
    "content": "Authelia validates the configuration when it starts. This process checks multiple factors including configuration keys that don’t exist, configuration keys that have changed, the values of the keys are valid, and that a configuration key isn’t supplied at the same time as a secret for the same configuration option. You may also optionally validate your configuration against this validation process manually by using the validate-config option with the Authelia binary as shown below. Keep in mind if you’re using secrets you will have to manually provide these if you don’t want to get certain validation errors (specifically requesting you provide one of the secret values). You can choose to ignore them if you know what you’re doing. This command is useful prior to upgrading to prevent configuration changes from impacting downtime in an upgrade. This process does not validate integrations, it only checks that your configuration syntax is valid. $ authelia validate-config configuration.yml . ",
    "url": "/docs/configuration/#validation",
    "relUrl": "/configuration/#validation"
  },"96": {
    "doc": "Configuration",
    "title": "Duration Notation Format",
    "content": "We have implemented a string based notation for configuration options that take a duration. This section describes its usage. You can use this implementation in: session for expiration, inactivity, and remember_me_duration; and regulation for ban_time, and find_time. This notation also supports just providing the number of seconds instead. The notation is comprised of a number which must be positive and not have leading zeros, followed by a letter denoting the unit of time measurement. The table below describes the units of time and the associated letter. | Unit | Associated Letter | . | Years | y | . | Months | M | . | Weeks | w | . | Days | d | . | Hours | h | . | Minutes | m | . | Seconds | s | . Examples: . | 1 hour and 30 minutes: 90m | 1 day: 1d | 10 hours: 10h | . ",
    "url": "/docs/configuration/#duration-notation-format",
    "relUrl": "/configuration/#duration-notation-format"
  },"97": {
    "doc": "Configuration",
    "title": "TLS Configuration",
    "content": "Various sections of the configuration use a uniform configuration section called TLS. Notably LDAP and SMTP. This section documents the usage. ",
    "url": "/docs/configuration/#tls-configuration",
    "relUrl": "/configuration/#tls-configuration"
  },"98": {
    "doc": "Configuration",
    "title": "Server Name",
    "content": "type: string . default: “” . required: no . The key server_name overrides the name checked against the certificate in the verification process. Useful if you require to use a direct IP address for the address of the backend service but want to verify a specific SNI. ",
    "url": "/docs/configuration/#server-name",
    "relUrl": "/configuration/#server-name"
  },"99": {
    "doc": "Configuration",
    "title": "Skip Verify",
    "content": "type: boolean . default: false . required: no . The key skip_verify completely negates validating the certificate of the backend service. This is not recommended, instead you should tweak the server_name option, and the global option certificates directory. ",
    "url": "/docs/configuration/#skip-verify",
    "relUrl": "/configuration/#skip-verify"
  },"100": {
    "doc": "Configuration",
    "title": "Minimum Version",
    "content": "type: string . default: TLS1.2 . required: no . The key minimum_version controls the minimum TLS version Authelia will use when opening TLS connections. The possible values are TLS1.3, TLS1.2, TLS1.1, TLS1.0. Anything other than TLS1.3 or TLS1.2 are very old and deprecated. You should avoid using these and upgrade your backend service instead of decreasing this value. ",
    "url": "/docs/configuration/#minimum-version",
    "relUrl": "/configuration/#minimum-version"
  },"101": {
    "doc": "Community",
    "title": "Community documentation",
    "content": "This section is meant to advertise and organize documentation produced by the community. This documentation is considered non-official and we will not guarantee that this documentation is up-to-date. If you think some of it should be considered official, please file an issue on GitHub. ",
    "url": "/docs/community/#community-documentation",
    "relUrl": "/community/#community-documentation"
  },"102": {
    "doc": "Community",
    "title": "Community",
    "content": " ",
    "url": "/docs/community/",
    "relUrl": "/community/"
  },"103": {
    "doc": "LDAP",
    "title": "LDAP",
    "content": "Authelia supports using a LDAP server as the users database. ",
    "url": "/docs/configuration/authentication/ldap.html",
    "relUrl": "/configuration/authentication/ldap.html"
  },"104": {
    "doc": "LDAP",
    "title": "Configuration",
    "content": "authentication_backend: disable_reset_password: false refresh_interval: 5m ldap: implementation: custom url: ldap://127.0.0.1 timeout: 5s start_tls: false tls: server_name: ldap.example.com skip_verify: false minimum_version: TLS1.2 base_dn: DC=example,DC=com username_attribute: uid additional_users_dn: ou=users users_filter: (&amp;({username_attribute}={input})(objectClass=person)) additional_groups_dn: ou=groups groups_filter: (&amp;(member={dn})(objectClass=groupOfNames)) group_name_attribute: cn mail_attribute: mail display_name_attribute: displayName user: CN=admin,DC=example,DC=com password: password . ",
    "url": "/docs/configuration/authentication/ldap.html#configuration",
    "relUrl": "/configuration/authentication/ldap.html#configuration"
  },"105": {
    "doc": "LDAP",
    "title": "Options",
    "content": "implementation . type: string . default: custom . required: no . Configures the LDAP implementation used by Authelia. See the Implementation Guide for information. url . type: string . required: yes . The LDAP URL which consists of a scheme, address, and port. Format is &lt;scheme&gt;://&lt;address&gt;:&lt;port&gt; or &lt;scheme&gt;://&lt;address&gt; where scheme is either ldap or ldaps. If utilising an IPv6 literal address it must be enclosed by square brackets: . url: ldap://[fd00:1111:2222:3333::1] . timeout . type: duration . default: 5s . required: no . The timeout for dialing an LDAP connection. start_tls . type: boolean . default: false . required: no . Enables use of the LDAP StartTLS process which is not commonly used. You should only configure this if you know you need it. The initial connection will be over plain text, and Authelia will try to upgrade it with the LDAP server. LDAPS URL’s are slightly more secure. tls . Controls the TLS connection validation process. You can see how to configure the tls section here. base_dn . type: string . required: yes . Sets the base distinguished name container for all LDAP queries. If your LDAP domain is example.com this is usually dc=example,dc=com, however you can fine tune this to be more specific for example to only include objects inside the authelia OU: ou=authelia,dc=example,dc=com. This is prefixed with the additional_users_dn for user searches and additional_groups_dn for groups searches. username_attribute . type: string . required: no . The LDAP attribute that maps to the username in Authelia. The default value is dependent on the implementation, refer to the attribute defaults for more information. additional_users_dn . type: string . required: no . Additional LDAP path to append to the base_dn when searching for users. Useful if you want to restrict exactly which OU to get users from for either security or performance reasons. For example setting it to ou=users,ou=people with a base_dn set to dc=example,dc=com will mean user searches will occur in ou=users,ou=people,dc=example,dc=com. The default value is dependent on the implementation, refer to the attribute defaults for more information. users_filter . type: string . required: no . The LDAP filter to narrow down which users are valid. This is important to set correctly as to exclude disabled users. The default value is dependent on the implementation, refer to the attribute defaults for more information. additional_groups_dn . Similar to additional_users_dn but it applies to group searches. groups_filter . Similar to users_filter but it applies to group searches. In order to include groups the memeber is not a direct member of, but is a member of another group that is a member of those (i.e. recursive groups), you may try using the following filter which is currently only tested against Microsoft Active Directory: . (&amp;(member:1.2.840.113556.1.4.1941:={dn})(objectClass=group)(objectCategory=group)) . mail_attribute . The attribute to retrieve which contains the users email addresses. This is important for the device registration and password reset processes. The user must have an email address in order for Authelia to perform identity verification when a user attempts to reset their password or register a second factor device. display_name_attribute . The attribute to retrieve which is shown on the Web UI to the user when they log in. user . The distinguished name of the user paired with the password to bind with for lookup and password change operations. password . The password of the user paired with the user to bind with for lookup and password change operations. Can also be defined using a secret which is the recommended for containerized deployments. ",
    "url": "/docs/configuration/authentication/ldap.html#options",
    "relUrl": "/configuration/authentication/ldap.html#options"
  },"106": {
    "doc": "LDAP",
    "title": "Implementation Guide",
    "content": "There are currently two implementations, custom and activedirectory. The activedirectory implementation must be used if you wish to allow users to change or reset their password as Active Directory uses a custom attribute for this, and an input format other implementations do not use. The long term intention of this is to have logical defaults for various RFC implementations of LDAP. Filter replacements . Various replacements occur in the user and groups filter. The replacements either occur at startup or upon an LDAP search. Users filter replacements . | Placeholder | Phase | Replacement | . | {username_attribute} | startup | The configured username attribute | . | {mail_attribute} | startup | The configured mail attribute | . | {display_name_attribute} | startup | The configured display name attribute | . | {input} | search | The input into the username field | . Groups filter replacements . | Placeholder | Phase | Replacement | . | {input} | search | The input into the username field | . | {username} | search | The username from the profile lookup obtained from the username attribute | . | {dn} | search | The distinguished name from the profile lookup | . Defaults . The below tables describes the current attribute defaults for each implementation. Attribute defaults . This table describes the attribute defaults for each implementation. i.e. the username_attribute is described by the Username column. | Implementation | Username | Display Name | Mail | Group Name | . | custom | n/a | displayName | mail | cn | . | activedirectory | sAMAccountName | displayName | mail | cn | . Filter defaults . The filters are probably the most important part to get correct when setting up LDAP. You want to exclude disabled accounts. The active directory example has two attribute filters that accomplish this as an example (more examples would be appreciated). The userAccountControl filter checks that the account is not disabled and the pwdLastSet makes sure that value is not 0 which means the password requires changing at the next login. | Implementation | Users Filter | Groups Filter | . | custom | n/a | n/a | . | activedirectory | (&amp;(|({username_attribute}={input})({mail_attribute}={input}))(sAMAccountType=805306368)(!(userAccountControl:1.2.840.113556.1.4.803:=2))(!(pwdLastSet=0))) | (&amp;(member={dn})(objectClass=group)(objectCategory=group)) | . Note: The Active Directory filter (sAMAccountType=805306368) is exactly the same as (&amp;(objectCategory=person)(objectClass=user)) except that the former is more performant, you can read more about this and other Active Directory filters on the TechNet wiki. ",
    "url": "/docs/configuration/authentication/ldap.html#implementation-guide",
    "relUrl": "/configuration/authentication/ldap.html#implementation-guide"
  },"107": {
    "doc": "LDAP",
    "title": "Refresh Interval",
    "content": "This setting takes a duration notation that sets the max frequency for how often Authelia contacts the backend to verify the user still exists and that the groups stored in the session are up to date. This allows us to destroy sessions when the user no longer matches the user_filter, or deny access to resources as they are removed from groups. In addition to the duration notation, you may provide the value always or disable. Setting to always is the same as setting it to 0 which will refresh on every request, disable turns the feature off, which is not recommended. This completely prevents Authelia from refreshing this information, and it would only be refreshed when the user session gets destroyed by other means like inactivity, session expiration or logging out and in. This value can be any value including 0, setting it to 0 would automatically refresh the session on every single request. This means Authelia will have to contact the LDAP backend every time an element on a page loads which could be substantially costly. It’s a trade-off between load and security that you should adapt according to your own security policy. ",
    "url": "/docs/configuration/authentication/ldap.html#refresh-interval",
    "relUrl": "/configuration/authentication/ldap.html#refresh-interval"
  },"108": {
    "doc": "LDAP",
    "title": "Important notes",
    "content": "Users must be uniquely identified by an attribute, this attribute must obviously contain a single value and be guaranteed by the administrator to be unique. If multiple users have the same value, Authelia will simply fail authenticating the user and display an error message in the logs. In order to avoid such problems, we highly recommended you follow https://www.ietf.org/rfc/rfc2307.txt by using sAMAccountName for Active Directory and uid for other implementations as the attribute holding the unique identifier for your users. As of versions &gt; 4.24.0 the users_filter must include the username_attribute placeholder, not including this will result in Authelia throwing an error. In versions &lt;= 4.24.0 not including the username_attribute placeholder will cause issues with the session refresh and will result in session resets when the refresh interval has expired, default of 5 minutes. ",
    "url": "/docs/configuration/authentication/ldap.html#important-notes",
    "relUrl": "/configuration/authentication/ldap.html#important-notes"
  },"109": {
    "doc": "Logging",
    "title": "Logging",
    "content": "The logging section tunes the logging settings. ",
    "url": "/docs/configuration/logging.html",
    "relUrl": "/configuration/logging.html"
  },"110": {
    "doc": "Logging",
    "title": "Configuration",
    "content": "log: level: info format: text file_path: \"\" keep_stdout: false . ",
    "url": "/docs/configuration/logging.html#configuration",
    "relUrl": "/configuration/logging.html#configuration"
  },"111": {
    "doc": "Logging",
    "title": "Options",
    "content": "level . type: string . default: info . required: no . Defines the level of logs used by Authelia. This level can be set to trace, debug, info, warn, or error. When setting level to trace, you will generate a large amount of log entries and expose the /debug/vars and /debug/pprof/ endpoints which should not be enabled in production. log: level: debug . format . type: string . default: text . required: no . Defines the format of the logs written by Authelia. This format can be set to json or text. log: format: json . JSON format . {\"level\":\"info\",\"msg\":\"Logging severity set to info\",\"time\":\"2020-01-01T00:00:00+11:00\"} {\"level\":\"info\",\"msg\":\"Authelia is listening for non-TLS connections on 0.0.0.0:9091\",\"time\":\"2020-01-01T00:00:00+11:00\"} . Text format . time=\"2020-01-01T00:00:00+11:00\" level=info msg=\"Logging severity set to info\" time=\"2020-01-01T00:00:00+11:00\" level=info msg=\"Authelia is listening for non-TLS connections on 0.0.0.0:9091\" . file_path . type: string (path) . default: “” . required: no . Logs can be stored in a file when file path is provided. Otherwise logs are written to standard output. When setting the level to debug or trace this will generate large amount of log entries. Administrators will need to ensure that they rotate and/or truncate the logs over time to prevent significant long-term disk usage. log: file_path: /config/authelia.log . keep_stdout . type: boolean . default: false . required: no . Overrides the behaviour to redirect logging only to the file_path. If set to true logs will be written to both standard output, and the defined logging location. log: keep_stdout: true . ",
    "url": "/docs/configuration/logging.html#options",
    "relUrl": "/configuration/logging.html#options"
  },"112": {
    "doc": "MariaDB",
    "title": "MariaDB",
    "content": "The MySQL storage provider also serves as a MariaDB provider. ",
    "url": "/docs/configuration/storage/mariadb.html",
    "relUrl": "/configuration/storage/mariadb.html"
  },"113": {
    "doc": "MariaDB",
    "title": "Configuration",
    "content": "storage: encryption_key: a_very_important_secret mysql: host: 127.0.0.1 port: 3306 database: authelia username: authelia password: mypassword . ",
    "url": "/docs/configuration/storage/mariadb.html#configuration",
    "relUrl": "/configuration/storage/mariadb.html#configuration"
  },"114": {
    "doc": "MariaDB",
    "title": "Options",
    "content": "encryption_key . See the encryption_key docs. host . type: string . required: yes . The database server host. If utilising an IPv6 literal address it must be enclosed by square brackets and quoted: . host: \"[fd00:1111:2222:3333::1]\" . port . type: integer . default: 3306 . required: no . The port the database server is listening on. database . type: string . required: yes . The database name on the database server that the assigned user has access to for the purpose of Authelia. username . type: string . required: yes . The username paired with the password used to connect to the database. password . type: string . required: yes . The password paired with the username used to connect to the database. Can also be defined using a secret which is also the recommended way when running as a container. timeout . type: duration . default: 5s . required: no . The SQL connection timeout. ",
    "url": "/docs/configuration/storage/mariadb.html#options",
    "relUrl": "/configuration/storage/mariadb.html#options"
  },"115": {
    "doc": "Security Measures",
    "title": "Security Measures",
    "content": " ",
    "url": "/docs/security/measures.html",
    "relUrl": "/security/measures.html"
  },"116": {
    "doc": "Security Measures",
    "title": "Protection against cookie theft",
    "content": "Authelia sets several key cookie attributes to prevent cookie theft: . | HttpOnly is set forbidding client-side code like javascript from access to the cookie. | Secure is set forbidding the browser from sending the cookie to sites which do not use the https scheme. | SameSite is by default set to Lax which prevents it being sent over cross-origin requests. | . Read about these attributes in detail on the MDN. ",
    "url": "/docs/security/measures.html#protection-against-cookie-theft",
    "relUrl": "/security/measures.html#protection-against-cookie-theft"
  },"117": {
    "doc": "Security Measures",
    "title": "Protection against multi-domain cookie attacks",
    "content": "Since Authelia uses multi-domain cookies to perform single sign-on, an attacker who poisoned a user’s DNS cache can easily retrieve the user’s cookies by making the user send a request to one of the attacker’s IPs. This is technically mitigated by the Secure attribute set in cookies by Authelia, however it’s still advisable to only use HTTPS connections with valid certificates and enforce it with HTTP Strict Transport Security (HSTS) which will prevent domains from serving over HTTP at all as long as the user has visited the domain before. This means even if the attacker poisons DNS they are unable to get modern browsers to connect to a compromised host unless they can also obtain the certificate. Note that using HSTS has consequences. That’s why you should read the blog post nginx has written on HSTS. ",
    "url": "/docs/security/measures.html#protection-against-multi-domain-cookie-attacks",
    "relUrl": "/security/measures.html#protection-against-multi-domain-cookie-attacks"
  },"118": {
    "doc": "Security Measures",
    "title": "Protection against username enumeration",
    "content": "Authelia adaptively delays authentication attempts based on the mean (average) of the previous 10 successful attempts in addition to a small random interval of time. The result of this delay is that it makes it incredibly difficult to determine if the unsuccessful login was the result of a bad password, a bad username, or both. The random interval of time is anything between 0 milliseconds and 85 milliseconds. When Authelia first starts it assumes the last 10 attempts took 1000 milliseconds each. As users login successfully it quickly adjusts to the actual time the login attempts take. This process is independent of the login backend you have configured. The cost of this is low since in the instance of a user not existing it just stops processing the request to delay the login. Lastly the absolute minimum time authentication can take is 250 milliseconds. Both of these measures also have the added effect of creating an additional delay for all authentication attempts increasing the time that a brute-force attack will take, this combined with regulation greatly delays brute-force attacks and the effectiveness of them in general. ",
    "url": "/docs/security/measures.html#protection-against-username-enumeration",
    "relUrl": "/security/measures.html#protection-against-username-enumeration"
  },"119": {
    "doc": "Security Measures",
    "title": "Protections against password cracking (File authentication provider)",
    "content": "Authelia implements a variety of measures to prevent an attacker cracking passwords if they somehow obtain the file used by the file authentication provider, this is unrelated to LDAP auth. First and foremost Authelia only uses very secure hashing algorithms with sane and secure defaults. The first and default hashing algorithm we use is Argon2id which is currently considered the most secure hashing algorithm. We also support SHA512, which previously was the default. Secondly Authelia uses salting with all hashing algorithms. These salts are generated with a random string generator, which is seeded every time it’s used by a cryptographically secure 1024bit prime number. This ensures that even if an attacker obtains the file, each password has to be brute forced individually. Lastly Authelia’s implementation of Argon2id is highly tunable. You can tune the key length, salt used, iterations (time), parallelism, and memory usage. To read more about this please read how to configure file authentication. ",
    "url": "/docs/security/measures.html#protections-against-password-cracking-file-authentication-provider",
    "relUrl": "/security/measures.html#protections-against-password-cracking-file-authentication-provider"
  },"120": {
    "doc": "Security Measures",
    "title": "User profile and group membership always kept up-to-date (LDAP authentication provider)",
    "content": "This measure is unrelated to the File authentication provider. Authelia by default refreshes the user’s profile and membership every 5 minutes. This ensures that if you alter a users groups in LDAP that their new groups are obtained relatively quickly in order to adjust their access level for applications secured by Authelia. Additionally, it will invalidate any session where the user could not be retrieved from LDAP based on the user filter, for example if they were deleted or disabled provided the user filter is set correctly. These updates occur when a user accesses a resource protected by Authelia. This means you should ensure disabled users or users with expired passwords are not obtainable using the LDAP filter, the default filter for Active Directory implements this behaviour. LDAP implementations vary, so please ask if you need some assistance in configuring this. These protections can be tuned according to your security policy by changing refresh_interval, however we believe that 5 minutes is a fairly safe interval. ",
    "url": "/docs/security/measures.html#user-profile-and-group-membership-always-kept-up-to-date-ldap-authentication-provider",
    "relUrl": "/security/measures.html#user-profile-and-group-membership-always-kept-up-to-date-ldap-authentication-provider"
  },"121": {
    "doc": "Security Measures",
    "title": "Notifier security measures (SMTP)",
    "content": "The SMTP Notifier implementation does not allow connections that are not secure without changing default configuration values. As such all SMTP connections require the following: . | TLS Connection (STARTTLS or SMTPS) has been negotiated before authentication or sending emails (unauthenticated connections require it as well) | Valid X509 Certificate presented to the client during the TLS handshake | . There is an option to disable both of these security measures however they are not recommended. The following configuration options exist to configure the security level in order of most preferable to least preferable: . Configuration Option: certificates_directory . You can configure a directory of certificates for Authelia to trust. These certificates can either be CA’s or individual public certificates that should be trusted. These are added in addition to the environments PKI trusted certificates if available. This is useful for trusting a certificate that is self-signed without drastically reducing security. This is the most recommended workaround to not having a valid PKI trusted certificate as it gives you complete control over which ones are trusted without disabling critically needed validation of the identity of the target service. Read more in the documentation for this option. Configuration Option: tls.skip_verify . The tls.skip_verify option allows you to skip verifying the certificate entirely which is why certificates_directory is preferred over this. This will effectively mean you cannot be sure the certificate is valid which means an attacker via DNS poisoning or MITM attacks could intercept emails from Authelia compromising a user’s security without their knowledge. Configuration Option: disable_require_tls . Authelia by default ensures that the SMTP server connection is secured via STARTTLS or SMTPS prior to sending sensitive information. The disable_require_tls disables this requirement which means the emails are sent in plain text. This is the least secure option as it effectively removes the validation of SMTP certificates and removes the encryption offered by the STARTTLS/SMTPS connection all together. This means not only can the vulnerabilities of the skip_verify option be exploited, but any router or switch along the route of the email which receives the packets could be used to silently exploit the plain text nature of the email. This is only usable currently with authentication disabled (comment out the password) and as such is only an option for SMTP servers that allow unauthenticated relay (bad practice). SMTPS vs STARTTLS . All connections start as plain text and are upgraded via STARTTLS. SMTPS is an exception to this rule where the connection is over TLS. As SMTPS is deprecated, the only way to configure this is to set the SMTP port to the officially recognized SMTPS port of 465 which will cause Authelia to automatically consider it to be a SMTPS connection. As such your SMTP server, if not offering SMTPS, should not be listening on port 465 which is bad practice anyway. ",
    "url": "/docs/security/measures.html#notifier-security-measures-smtp",
    "relUrl": "/security/measures.html#notifier-security-measures-smtp"
  },"122": {
    "doc": "Security Measures",
    "title": "Additional security",
    "content": "Reset Password . It’s possible to disable the reset password functionality and is an optional adjustment to consider for anyone wanting to increase security. See the configuration for more information. Session security . We have a few options to configure the security of a session. The main and most important one is the session secret. This is used to encrypt the session data when it is stored in the Redis key value database. The value of this option should be long and as random as possible. See more in the documentation for this option. The validity period of session is highly configurable. For example in a highly security conscious domain you could set the session remember_me_duration to 0 to disable this feature, and set the expiration to 2 hours and the inactivity of 10 minutes. Configuring the session security in this manner would mean if the cookie age was more than 2 hours or if the user was inactive for more than 10 minutes the session would be destroyed. Additional proxy protection measures . You can also apply the following headers to your proxy configuration for improving security. Please read the relevant documentation for these headers before applying them blindly. nginx . # We don't want any credentials / TOTP secret key / QR code to be cached by # the client add_header Cache-Control \"no-store\"; add_header Pragma \"no-cache\"; # Clickjacking / XSS protection # We don't want Authelia's login page to be rendered within a &lt;frame&gt;, # &lt;iframe&gt; or &lt;object&gt; from an external website. add_header X-Frame-Options \"SAMEORIGIN\"; # Block pages from loading when they detect reflected XSS attacks. add_header X-XSS-Protection \"1; mode=block\"; . Traefik 2.x - Kubernetes CRD . --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: headers-authelia spec: headers: browserXssFilter: true customFrameOptionsValue: \"SAMEORIGIN\" customResponseHeaders: Cache-Control: \"no-store\" Pragma: \"no-cache\" --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: authelia spec: entryPoints: - http routes: - match: Host(`auth.example.com`) &amp;&amp; PathPrefix(`/`) kind: Rule priority: 1 middlewares: - name: headers-authelia namespace: authelia services: - name: authelia port: 80 . Traefik 2.x - docker-compose . services: authelia: labels: - \"traefik.http.routers.authelia.middlewares=authelia-headers\" - \"traefik.http.middlewares.authelia-headers.headers.browserXssFilter=true\" - \"traefik.http.middlewares.authelia-headers.headers.customFrameOptionsValue=SAMEORIGIN\" - \"traefik.http.middlewares.authelia-headers.headers.customResponseHeaders.Cache-Control=no-store\" - \"traefik.http.middlewares.authelia-headers.headers.customResponseHeaders.Pragma=no-cache\" . More protections measures with fail2ban . If you are running fail2ban, adding a filter and jail for Authelia can reduce load on the application / web server. Fail2ban will ban IPs exceeding a threshold of repeated failed logins at the firewall level of your host. If you are using Docker, the Authelia log file location has to be mounted from the host system to the container for fail2ban to access it. Create a configuration file in the filter.d folder with the content below. In Debian-based systems the folder is typically located at /etc/fail2ban/filter.d. # Fail2Ban filter for Authelia # Make sure that the HTTP header \"X-Forwarded-For\" received by Authelia's backend # only contains a single IP address (the one from the end-user), and not the proxy chain # (it is misleading: usually, this is the purpose of this header). # the failregex rule counts every failed 1FA attempt (first line, wrong username or password) and failed 2FA attempt # second line) as a failure. # the ignoreregex rule ignores debug, info and warning messages as all authentication failures are flagged as errors [Definition] failregex = ^.*Unsuccessful 1FA authentication attempt by user .*remote_ip=\"?&lt;HOST&gt;\"? stack.* ^.*Unsuccessful (TOTP|DUO|U2F) authentication attempt by user .*remote_ip=\"?&lt;HOST&gt;\"? stack.* ignoreregex = ^.*level=debug.* ^.*level=info.* ^.*level=warning.* . Modify the jail.local file. In Debian-based systems the folder is typically located at /etc/fail2ban/. If the file does not exist, create it by copying the jail.conf cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local. Add an Authelia entry to the “Jails” section of the file: . [authelia] enabled = true port = http,https,9091 filter = authelia logpath = /path-to-your-authelia.log maxretry = 3 bantime = 1d findtime = 1d chain = DOCKER-USER . If you are not using Docker remove the line “chain = DOCKER-USER”. You will need to restart the fail2ban service for the changes to take effect. ",
    "url": "/docs/security/measures.html#additional-security",
    "relUrl": "/security/measures.html#additional-security"
  },"123": {
    "doc": "Security Measures",
    "title": "Container privilege de-escalation",
    "content": "Authelia will run as the root user and group by default, there are two options available to run as a non-root user and group. It is recommended which ever approach you take that to secure the sensitive files Authelia requires access to that you make sure the chmod of the files does not inadvertently allow read access to the files by users who do not need access to them. Examples: . If you wanted to run Authelia as UID 8000, and wanted the GID of 9000 to also have read access to the files you might do the following assuming the files were in the relative path .data/authelia: . chown -r 8000:9000 .data/authelia find .data/authelia/ -type d -exec chmod 750 {} \\; find .data/authelia/ -type f -exec chmod 640 {} \\; . If you wanted to run Authelia as UID 8000, and wanted the GID of 9000 to also have write access to the files you might do the following assuming the files were in the relative path .data/authelia: . chown -r 8000:9000 .data/authelia find .data/authelia/ -type d -exec chmod 770 {} \\; find .data/authelia/ -type f -exec chmod 660 {} \\; . Docker user directive . The docker user directive allows you to configure the user the entrypoint runs as. This is generally the most secure option for containers as no process accessible to the container ever runs as root which prevents a compromised container from exploiting unnecessary privileges. The directive can either be applied in your docker run command using the --user argument or by the docker-compose user: key. The examples below assume you’d like to run the container as UID 8000 and GID 9000. Example for the docker CLI: . docker run --user 8000:9000 -v /authelia:/config authelia/authelia:latest . Example for docker-compose: . version: '3.8' services: authelia: image: authelia/authelia container_name: authelia user: 8000:9000 volumes: - ./authelia:/config . Running the container in this way requires that you manually adjust the file owner at the very least as described above. If you do not do so it will likely cause Authelia to exit immediately. This option takes precedence over the PUID and PGID environment variables below, so if you use it then changing the PUID and PGID have zero effect. PUID/PGID environment variables using the entrypoint . The second option is to use the PUID and PGID environment variables. When the container entrypoint is executed as root, the entrypoint automatically runs the Authelia process as this user. An added benefit of using the environment variables is the mounted volumes ownership will automatically be changed for you. It is still recommended that you run the find chmod examples above in order to secure the files even further especially on servers multiple people have access to. The examples below assume you’d like to run the container as UID 8000 and GID 9000. Example for the docker CLI: . docker run -e PUID=1000 -e PGID=1000 -v /authelia:/config authelia/authelia:latest . Example for docker-compose: . version: '3.8' services: authelia: image: authelia/authelia container_name: authelia environment: PUID: 1000 PGID: 1000 volumes: - ./authelia:/config . ",
    "url": "/docs/security/measures.html#container-privilege-de-escalation",
    "relUrl": "/security/measures.html#container-privilege-de-escalation"
  },"124": {
    "doc": "Migration",
    "title": "Format",
    "content": "The migrations are formatted in a table with the old key and the new key. Periods indicate a different section which can be represented in YAML as a dictionary i.e. it’s indented. In our table server.host with a value of 0.0.0.0 is represented in YAML like this: . server: host: 0.0.0.0 . ",
    "url": "/docs/configuration/migration.html#format",
    "relUrl": "/configuration/migration.html#format"
  },"125": {
    "doc": "Migration",
    "title": "Policy",
    "content": "Our deprecation policy for configuration keys is 3 minor versions. For example if a configuration option is deprecated in version 4.30.0, it will remain as a warning for 4.30.x, 4.31.x, and 4.32.x; then it will become a fatal error in 4.33.0+. ",
    "url": "/docs/configuration/migration.html#policy",
    "relUrl": "/configuration/migration.html#policy"
  },"126": {
    "doc": "Migration",
    "title": "Migrations",
    "content": "4.33.0 . The options deprecated in version 4.30.0 have been fully removed as per our deprecation policy and warnings logged for users. 4.30.0 . The following changes occurred in 4.30.0: . | Previous Key | New Key | . | host | server.host | . | port | server.port | . | tls_key | server.tls.key | . | tls_cert | server.tls.certificate | . | log_level | log.level | . | log_file_path | log.file_path | . | log_format | log.format | . Please Note: you can no longer define secrets for providers that you are not using. For example if you’re using the filesystem notifier you must ensure that the AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE environment variable or other environment variables set. This also applies to other providers like storage and authentication backend. Kubernetes 4.30.0 . Please Note: if you’re using Authelia with Kubernetes and are not using the provided helm chart you will be required to set the following option in your PodSpec. Keeping in mind this example is for a Pod, not for a Deployment, StatefulSet, or DaemonSet; you will need to adapt the enableServiceLinks option to fit into the relevant location depending on your needs. --- apiVersion: v1 kind: Pod metadata: name: authelia spec: enableServiceLinks: false ... 4.25.0 . The following changes occurred in 4.25.0: . | Previous Key | New Key | . | authentication_backend.ldap.tls.skip_verify | authentication_backend.ldap.tls.skip_verify | . | authentication_backend.ldap.minimum_tls_version | authentication_backend.ldap.tls.minimum_version | . | notifier.smtp.disable_verify_cert | notifier.smtp.tls.skip_verify | . | notifier.smtp.trusted_cert | certificates_directory | . Please Note: certificates_directory is not a direct replacement for the notifier.smtp.trusted_cert, instead of being the path to a specific file it is a path to a directory containing certificates trusted by Authelia. This affects other services like LDAP as well. 4.7.0 . The following changes occurred in 4.7.0: . | Previous Key | New Key | . | logs_level | log_level | . | logs_file | log_file | . Please Note: The new keys also changed in 4.30.0 so you will need to update them to the new values if you are using 4.30.0 or newer instead of the new keys listed here. ",
    "url": "/docs/configuration/migration.html#migrations",
    "relUrl": "/configuration/migration.html#migrations"
  },"127": {
    "doc": "Migration",
    "title": "Migration",
    "content": "This section documents changes in the configuration which may require manual migration by the administrator. Typically this only occurs when a configuration key is renamed or moved to a more appropriate location. ",
    "url": "/docs/configuration/migration.html",
    "relUrl": "/configuration/migration.html"
  },"128": {
    "doc": "Migrations",
    "title": "Schema Version to Authelia Version map",
    "content": "This table contains a list of schema versions and the corresponding release of Authelia that shipped with that version. This means all Authelia versions between two schema versions use the first schema version. For example for version pre1, it is used for all versions between it and the version 1 schema, so 4.0.0 to 4.32.2. In this instance if you wanted to downgrade to pre1 you would need to use an Authelia binary with version 4.33.0 or higher. | Schema Version | Authelia Version | Notes | . | pre1 | 4.0.0 | Downgrading to this version requires you use the –pre1 flag | . | 1 | 4.33.0 |   | . ",
    "url": "/docs/configuration/storage/migrations.html#schema-version-to-authelia-version-map",
    "relUrl": "/configuration/storage/migrations.html#schema-version-to-authelia-version-map"
  },"129": {
    "doc": "Migrations",
    "title": "Migrations",
    "content": "Storage migrations are important for keeping your database compatible with Authelia. Authelia will automatically upgrade your schema on startup. However, if you wish to use an older version of Authelia you may be required to manually downgrade your schema with a version of Authelia that supports your current schema. ",
    "url": "/docs/configuration/storage/migrations.html",
    "relUrl": "/configuration/storage/migrations.html"
  },"130": {
    "doc": "Miscellaneous",
    "title": "Miscellaneous",
    "content": "Here are the main customizable options in Authelia that don’t fit into their own sections. ",
    "url": "/docs/configuration/miscellaneous.html",
    "relUrl": "/configuration/miscellaneous.html"
  },"131": {
    "doc": "Miscellaneous",
    "title": "certificates_directory",
    "content": "This option defines the location of additional certificates to load into the trust chain specifically for Authelia. This currently affects both the SMTP notifier and the LDAP authentication backend. The certificates should all be in the PEM format and end with the extension .pem, .crt, or .cer. You can either add the individual certificates public key or the CA public key which signed them (don’t add the private key). certificates_directory: /config/certs/ . ",
    "url": "/docs/configuration/miscellaneous.html#certificates_directory",
    "relUrl": "/configuration/miscellaneous.html#certificates_directory"
  },"132": {
    "doc": "Miscellaneous",
    "title": "jwt_secret",
    "content": "type: string . default: “” . required: yes . Defines the secret used to craft JWT tokens leveraged by the identity verification process. This can also be defined using a secret. jwt_secret: v3ry_important_s3cr3t . ",
    "url": "/docs/configuration/miscellaneous.html#jwt_secret",
    "relUrl": "/configuration/miscellaneous.html#jwt_secret"
  },"133": {
    "doc": "Miscellaneous",
    "title": "default_redirection_url",
    "content": "type: string . default: “” . required: no . The default redirection URL is the URL where users are redirected when Authelia cannot detect the target URL where the user was heading. In a normal authentication workflow, a user tries to access a website and she gets redirected to the sign-in portal in order to authenticate. Since the user initially targeted a website, the portal knows where the user was heading and can redirect her after the authentication process. However, when a user visits the sign in portal directly, the portal considers the targeted website is the portal. In that case and if the default redirection URL is configured, the user is redirected to that URL. If not defined, the user is not redirected after authentication. default_redirection_url: https://home.example.com:8080/ . ",
    "url": "/docs/configuration/miscellaneous.html#default_redirection_url",
    "relUrl": "/configuration/miscellaneous.html#default_redirection_url"
  },"134": {
    "doc": "MySQL",
    "title": "MySQL",
    "content": "The MySQL storage provider. ",
    "url": "/docs/configuration/storage/mysql.html",
    "relUrl": "/configuration/storage/mysql.html"
  },"135": {
    "doc": "MySQL",
    "title": "Configuration",
    "content": "storage: encryption_key: a_very_important_secret mysql: host: 127.0.0.1 port: 3306 database: authelia username: authelia password: mypassword timeout: 5s . ",
    "url": "/docs/configuration/storage/mysql.html#configuration",
    "relUrl": "/configuration/storage/mysql.html#configuration"
  },"136": {
    "doc": "MySQL",
    "title": "Options",
    "content": "encryption_key . See the encryption_key docs. host . type: string . default: localhost . required: no . The database server host. If utilising an IPv6 literal address it must be enclosed by square brackets and quoted: . host: \"[fd00:1111:2222:3333::1]\" . port . type: integer . default: 3306 . required: no . The port the database server is listening on. database . type: string . required: yes . The database name on the database server that the assigned user has access to for the purpose of Authelia. username . type: string . required: yes . The username paired with the password used to connect to the database. password . type: string . required: yes . The password paired with the username used to connect to the database. Can also be defined using a secret which is also the recommended way when running as a container. timeout . type: duration . default: 5s . required: no . The SQL connection timeout. ",
    "url": "/docs/configuration/storage/mysql.html#options",
    "relUrl": "/configuration/storage/mysql.html#options"
  },"137": {
    "doc": "NGINX",
    "title": "NGINX",
    "content": "NGINX is a reverse proxy supported by Authelia. ",
    "url": "/docs/deployment/supported-proxies/nginx.html",
    "relUrl": "/deployment/supported-proxies/nginx.html"
  },"138": {
    "doc": "NGINX",
    "title": "Configuration",
    "content": "Below you will find commented examples of the following configuration: . | Authelia portal | Protected endpoint (Nextcloud) | Supplementary config | . With the below configuration you can add authelia.conf to virtual hosts to support protection with Authelia. auth.conf is utilised to enable the protection either at the root location or a more specific location/route. proxy.conf is included just for completeness. Supplementary config . authelia.conf . set $upstream_authelia http://authelia:9091/api/verify; # Virtual endpoint created by nginx to forward auth requests. location /authelia { internal; proxy_pass_request_body off; proxy_pass $upstream_authelia; proxy_set_header Content-Length \"\"; # Timeout if the real server is dead proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; # [REQUIRED] Needed by Authelia to check authorizations of the resource. # Provide either X-Original-URL and X-Forwarded-Proto or # X-Forwarded-Proto, X-Forwarded-Host and X-Forwarded-Uri or both. # Those headers will be used by Authelia to deduce the target url of the user. # Basic Proxy Config client_body_buffer_size 128k; proxy_set_header Host $host; proxy_set_header X-Original-URL $scheme://$http_host$request_uri; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Method $request_method; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-Uri $request_uri; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Ssl on; proxy_redirect http:// $scheme://; proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_cache_bypass $cookie_session; proxy_no_cache $cookie_session; proxy_buffers 4 32k; # Advanced Proxy Config send_timeout 5m; proxy_read_timeout 240; proxy_send_timeout 240; proxy_connect_timeout 240; } . auth.conf . # Basic Authelia Config # Send a subsequent request to Authelia to verify if the user is authenticated # and has the right permissions to access the resource. auth_request /authelia; # Set the `target_url` variable based on the request. It will be used to build the portal # URL with the correct redirection parameter. auth_request_set $target_url $scheme://$http_host$request_uri; # Set the X-Forwarded-User and X-Forwarded-Groups with the headers # returned by Authelia for the backends which can consume them. # This is not safe, as the backend must make sure that they come from the # proxy. In the future, it's gonna be safe to just use OAuth. auth_request_set $user $upstream_http_remote_user; auth_request_set $groups $upstream_http_remote_groups; auth_request_set $name $upstream_http_remote_name; auth_request_set $email $upstream_http_remote_email; proxy_set_header Remote-User $user; proxy_set_header Remote-Groups $groups; proxy_set_header Remote-Name $name; proxy_set_header Remote-Email $email; # If Authelia returns 401, then nginx redirects the user to the login portal. # If it returns 200, then the request pass through to the backend. # For other type of errors, nginx will handle them as usual. error_page 401 =302 https://auth.example.com/?rd=$target_url; . proxy.conf . client_body_buffer_size 128k; #Timeout if the real server is dead proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; # Advanced Proxy Config send_timeout 5m; proxy_read_timeout 360; proxy_send_timeout 360; proxy_connect_timeout 360; # Basic Proxy Config proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-Uri $request_uri; proxy_set_header X-Forwarded-Ssl on; proxy_redirect http:// $scheme://; proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_cache_bypass $cookie_session; proxy_no_cache $cookie_session; proxy_buffers 64 256k; # If behind reverse proxy, forwards the correct IP set_real_ip_from 10.0.0.0/8; set_real_ip_from 172.16.0.0/12; set_real_ip_from 192.168.0.0/16; set_real_ip_from fc00::/7; real_ip_header X-Forwarded-For; real_ip_recursive on; . Authelia Portal . server { server_name auth.example.com; listen 80; return 301 https://$server_name$request_uri; } server { server_name auth.example.com; listen 443 ssl http2; include /config/nginx/ssl.conf; location / { set $upstream_authelia http://authelia:9091; # This example assumes a Docker deployment proxy_pass $upstream_authelia; include /config/nginx/proxy.conf; } } . Protected Endpoint . server { server_name nextcloud.example.com; listen 80; return 301 https://$server_name$request_uri; } server { server_name nextcloud.example.com; listen 443 ssl http2; include /config/nginx/ssl.conf; include /config/nginx/authelia.conf; # Virtual endpoint to forward auth requests location / { set $upstream_nextcloud https://nextcloud; proxy_pass $upstream_nextcloud; include /config/nginx/auth.conf; # Activates Authelia for specified route/location, please ensure you have setup the domain in your configuration.yml include /config/nginx/proxy.conf; # Reverse proxy configuration } } . Basic Auth Example . Here’s an example for using HTTP basic auth on a specific endpoint. It is based on the full example above. authelia-basic.conf . # Notice we added the auth=basic query arg here set $upstream_authelia http://authelia:9091/api/verify?auth=basic; location /authelia { internal; proxy_pass_request_body off; proxy_pass $upstream_authelia; proxy_set_header Content-Length \"\"; # Timeout if the real server is dead proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; # [REQUIRED] Needed by Authelia to check authorizations of the resource. # Provide either X-Original-URL and X-Forwarded-Proto or # X-Forwarded-Proto, X-Forwarded-Host and X-Forwarded-Uri or both. # Those headers will be used by Authelia to deduce the target url of the user. # Basic Proxy Config client_body_buffer_size 128k; proxy_set_header Host $host; proxy_set_header X-Original-URL $scheme://$http_host$request_uri; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Method $request_method; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-Uri $request_uri; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Ssl on; proxy_redirect http:// $scheme://; proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_cache_bypass $cookie_session; proxy_no_cache $cookie_session; proxy_buffers 4 32k; # Advanced Proxy Config send_timeout 5m; proxy_read_timeout 240; proxy_send_timeout 240; proxy_connect_timeout 240; } . auth-basic.conf . Same as auth.conf but without the error_page directive. We want nginx to proxy the 401 back to the client, not to return a 301. # Basic Authelia Config # Send a subsequent request to Authelia to verify if the user is authenticated # and has the right permissions to access the resource. auth_request /authelia; # Set the `target_url` variable based on the request. It will be used to build the portal # URL with the correct redirection parameter. auth_request_set $target_url $scheme://$http_host$request_uri; # Set the X-Forwarded-User and X-Forwarded-Groups with the headers # returned by Authelia for the backends which can consume them. # This is not safe, as the backend must make sure that they come from the # proxy. In the future, it's gonna be safe to just use OAuth. auth_request_set $user $upstream_http_remote_user; auth_request_set $groups $upstream_http_remote_groups; auth_request_set $name $upstream_http_remote_name; auth_request_set $email $upstream_http_remote_email; proxy_set_header Remote-User $user; proxy_set_header Remote-Groups $groups; proxy_set_header Remote-Name $name; proxy_set_header Remote-Email $email; # If Authelia returns 401, then nginx passes it to the user. # If it returns 200, then the request pass through to the backend. Protected Endpoint . server { server_name nextcloud.example.com; listen 80; return 301 https://$server_name$request_uri; } server { server_name nextcloud.example.com; listen 443 ssl http2; include /config/nginx/ssl.conf; include /config/nginx/authelia-basic.conf; # Use the \"basic\" endpoint location / { set $upstream_nextcloud https://nextcloud; proxy_pass $upstream_nextcloud; include /config/nginx/auth-basic.conf; # Activate authelia with basic auth include /config/nginx/proxy.conf; # this file is the exact same as above } } . Basic auth for specific client . If you’d like to force basic auth for some requests, you can use the following template: . authelia-detect.conf . set $is_basic_auth \"\"; # false value set $upstream_authelia http://authelia:9091/api/verify; # Detect the client you want to force basic auth for here # For the example we just match a path on the original request if ($request_uri = \"/force-basic\") { set $is_basic_auth \"true\"; set $upstream_authelia \"$upstream_authelia?auth=basic\"; } location = /authelia { # Same as above } # A new virtual endpoint to used if the auth_request failed location = /authelia-redirect { internal; if ($is_basic_auth) { # This is a request where we decided to use basic auth, return a 401. # Nginx will also proxy back the WWW-Authenticate header from Authelia's # response. This is what informs the client we're expecting basic auth. return 401; } # The original request didn't target /force-basic, redirect to the pretty login page # This is what `error_page 401 =302 https://auth.example.com/?rd=$target_url;` did. return 302 https://auth.example.com/$is_args$args; } . auth.conf . Here we replace error_page directive to determine if basic auth should be utilised or not. # Basic Authelia Config # Send a subsequent request to Authelia to verify if the user is authenticated # and has the right permissions to access the resource. auth_request /authelia; # Set the `target_url` variable based on the request. It will be used to build the portal # URL with the correct redirection parameter. auth_request_set $target_url $scheme://$http_host$request_uri; # Set the X-Forwarded-User and X-Forwarded-Groups with the headers # returned by Authelia for the backends which can consume them. # This is not safe, as the backend must make sure that they come from the # proxy. In the future, it's gonna be safe to just use OAuth. auth_request_set $user $upstream_http_remote_user; auth_request_set $groups $upstream_http_remote_groups; auth_request_set $name $upstream_http_remote_name; auth_request_set $email $upstream_http_remote_email; proxy_set_header Remote-User $user; proxy_set_header Remote-Groups $groups; proxy_set_header Remote-Name $name; proxy_set_header Remote-Email $email; # If Authelia returns 401, then nginx passes it to the user. # If it returns 200, then the request pass through to the backend. error_page 401 /authelia-redirect?rd=$target_url; . This tells nginx to use the virtual endpoint we defined above in case the auth_request failed. ",
    "url": "/docs/deployment/supported-proxies/nginx.html#configuration",
    "relUrl": "/deployment/supported-proxies/nginx.html#configuration"
  },"139": {
    "doc": "NTP",
    "title": "NTP",
    "content": "Authelia has the ability to check the system time against an NTP server. Currently this only occurs at startup. This section configures and tunes the settings for this check which is primarily used to ensure TOTP can be accurately validated. In the instance of inability to contact the NTP server Authelia will just log an error and will continue to run. ",
    "url": "/docs/configuration/ntp.html",
    "relUrl": "/configuration/ntp.html"
  },"140": {
    "doc": "NTP",
    "title": "Configuration",
    "content": "ntp: address: \"time.cloudflare.com:123\" version: 3 max_desync: 3s disable_startup_check: false disable_failure: false . ",
    "url": "/docs/configuration/ntp.html#configuration",
    "relUrl": "/configuration/ntp.html#configuration"
  },"141": {
    "doc": "NTP",
    "title": "Options",
    "content": "address . type: string . default: time.cloudflare.com:123 . required: no . Determines the address of the NTP server to retrieve the time from. The format is &lt;host&gt;:&lt;port&gt;, and both of these are required. version . type: integer . default: 4 . required: no . Determines the NTP verion supported. Valid values are 3 or 4. max_desync . type: duration . default: 3s . required: no . This is used to tune the acceptable desync from the time reported from the NTP server. This uses our duration notation format. disable_startup_check . type: boolean . default: false . required: no . Setting this to true will disable the startup check entirely. disable_failure . type: boolean . default: false . required: no . Setting this to true will allow Authelia to start and just log an error instead of exiting. The default is that if Authelia can contact the NTP server successfully, and the time reported by the server is greater than what is configured in max_desync that Authelia fails to start and logs a fatal error. ",
    "url": "/docs/configuration/ntp.html#options",
    "relUrl": "/configuration/ntp.html#options"
  },"142": {
    "doc": "Community-Tested OIDC Integrations",
    "title": "OIDC Integrations",
    "content": "Note This is community-based content for which the core-maintainers cannot guarantee correctness. The parameters may change over time. If a parameter does not work as documented, please submit a PR to update the list. ",
    "url": "/docs/community/oidc-integrations.html#oidc-integrations",
    "relUrl": "/community/oidc-integrations.html#oidc-integrations"
  },"143": {
    "doc": "Community-Tested OIDC Integrations",
    "title": "Currently Tested Applications",
    "content": "| Application | Minimal Version | Notes | . | Gitea | 1.14.6 |   | . | GitLab | 13.0.0 |   | . | Grafana | 8.0.5 |   | . | Hashicorp Vault | 1.8.1 |   | . | MinIO | RELEASE.2021-11-09T03-21-45Z | must set MINIO_IDENTITY_OPENID_CLAIM_NAME: groups in MinIO and set MinIO policies as groups in Authelia | . | Nextcloud | 22.1.0 | Tested using the nextcloud-oidc-login app - Link | . | Wekan | 5.41 |   | . | Portainer CE | 2.6.1 | Settings to use username as ID: set Scopes to openid and User Identifier to sub | . ",
    "url": "/docs/community/oidc-integrations.html#currently-tested-applications",
    "relUrl": "/community/oidc-integrations.html#currently-tested-applications"
  },"144": {
    "doc": "Community-Tested OIDC Integrations",
    "title": "Known Callback URLs",
    "content": "If you do not find the application in the list below, you will need to search for yourself - and maybe come back to open a PR to add your application to this list so others won’t have to search for them. &lt;DOMAIN&gt; needs to be substituted with the full URL on which the application runs on. If GitLab, as an example, was reachable under https://gitlab.example.com, &lt;DOMAIN&gt; would be exactly the same. | Application | Version | Callback URL | Notes | . | Gitea | 1.14.6 | &lt;DOMAIN&gt;/user/oauth2/authelia/callback | ROOT_URL in [server] section of app.ini must be configured correctly. Typically it is &lt;DOMAIN&gt;/. The string authelia in the callback url is the Authentication Name of the configured Authentication Source in Gitea (Authentication Type: OAuth2, OAuth2 Provider: OpenID Connect). | . | GitLab | 14.0.1 | &lt;DOMAIN&gt;/users/auth/openid_connect/callback |   | . | Hasicorp Vault | 14.0.1 | &lt;DOMAIN&gt;/oidc/callback and &lt;DOMAIN&gt;/ui/vault/auth/oidc/oidc/callback |   | . | MinIO | RELEASE.2021-07-12T02-44-53Z | &lt;DOMAIN&gt;/oauth_callback |   | . | Nextcloud | 22.1.0 + nextcloud-oidc-login app | &lt;DOMAIN&gt;/apps/oidc_login/oidc |   | . | Wekan | 5.41 | &lt;DOMAIN&gt;/_oauth_oidc |   | . | Portainer CE | 2.6.1 | &lt;DOMAIN&gt; |   | . ",
    "url": "/docs/community/oidc-integrations.html#known-callback-urls",
    "relUrl": "/community/oidc-integrations.html#known-callback-urls"
  },"145": {
    "doc": "Community-Tested OIDC Integrations",
    "title": "Community-Tested OIDC Integrations",
    "content": " ",
    "url": "/docs/community/oidc-integrations.html",
    "relUrl": "/community/oidc-integrations.html"
  },"146": {
    "doc": "OpenID Connect",
    "title": "OpenID Connect",
    "content": "Authelia currently supports the OpenID Connect OP role as a beta feature. The OP role is the OpenID Connect Provider role, not the Relying Party or RP role. This means other applications that implement the OpenID Connect RP role can use Authelia as an authentication and authorization backend similar to how you may use social media or development platforms for login. The Relying Party role is the role which allows an application to use GitHub, Google, or other OpenID Connect providers for authentication and authorization. We do not intend to support this functionality at this moment in time. ",
    "url": "/docs/configuration/identity-providers/oidc.html",
    "relUrl": "/configuration/identity-providers/oidc.html"
  },"147": {
    "doc": "OpenID Connect",
    "title": "Roadmap",
    "content": "We have decided to implement OpenID Connect as a beta feature, it’s suggested you only utilize it for testing and providing feedback, and should take caution in relying on it in production as of now. OpenID Connect and it’s related endpoints are not enabled by default unless you specifically configure the OpenID Connect section. As OpenID Connect is fairly complex (the OpenID Connect Provider role especially so) it’s intentional that it is both a beta and that the implemented features are part of a thoughtful roadmap. Items that are not immediately obvious as required (i.e. bug fixes or spec features), will likely be discussed in team meetings or on GitHub issues before being added to the list. We want to implement this feature in a very thoughtful way in order to avoid security issues. The beta will be broken up into stages. Each stage will bring additional features. The following table is a rough plan for which stage will have each feature, and may evolve over time: . | Stage | Feature Description | . | beta1 (4.29.0) | User Consent | . | Authorization Code Flow | . | OpenID Connect Discovery | . | RS256 Signature Strategy | . | Per Client Scope/Grant Type/Response Type Restriction | . | Per Client Authorization Policy (1FA/2FA) | . | Per Client List of Valid Redirection URI's | . | Confidential Client Type | . | beta2 (4.30.0) | Userinfo Endpoint (missed in beta1) | . | Parameter Entropy Configuration | . | Token/Code Lifespan Configuration | . | Client Debug Messages | . | Client Audience | . | Public Client Type | . | beta3 1 | Token Storage | . | Audit Storage | . | beta4 1 | Back-Channel Logout | . | Deny Refresh on Session Expiration | . | Signing Key Rotation Policy | . | Client Secrets Hashed in Configuration | . | GA 1 | General Availability after previous stages are vetted for bug fixes | . | misc | List of other features that may be implemented | . | Front-Channel Logout 2 | . | OAuth 2.0 Authorization Server Metadata 2 | . | OpenID Connect Session Management 2 | . ¹ This stage has not been implemented as of yet. ² This individual feature has not been implemented as of yet. ",
    "url": "/docs/configuration/identity-providers/oidc.html#roadmap",
    "relUrl": "/configuration/identity-providers/oidc.html#roadmap"
  },"148": {
    "doc": "OpenID Connect",
    "title": "Configuration",
    "content": "The following snippet provides a sample-configuration for the OIDC identity provider explaining each field in detail. identity_providers: oidc: hmac_secret: this_is_a_secret_abc123abc123abc issuer_private_key: | --- KEY START --- KEY END access_token_lifespan: 1h authorize_code_lifespan: 1m id_token_lifespan: 1h refresh_token_lifespan: 90m enable_client_debug_messages: false clients: - id: myapp description: My Application secret: this_is_a_secret public: false authorization_policy: two_factor audience: [] scopes: - openid - groups - email - profile redirect_uris: - https://oidc.example.com:8080/oauth2/callback grant_types: - refresh_token - authorization_code response_types: - code response_modes: - form_post - query - fragment userinfo_signing_algorithm: none . ",
    "url": "/docs/configuration/identity-providers/oidc.html#configuration",
    "relUrl": "/configuration/identity-providers/oidc.html#configuration"
  },"149": {
    "doc": "OpenID Connect",
    "title": "Options",
    "content": "hmac_secret . type: string . required: yes . The HMAC secret used to sign the OpenID Connect JWT’s. The provided string is hashed to a SHA256 byte string for the purpose of meeting the required format. You must generate this option yourself. Should be defined using a secret which is the recommended for containerized deployments. issuer_private_key . type: string . required: yes . The private key in DER base64 encoded PEM format used to encrypt the OpenID Connect JWT’s.¹ You must generate this option yourself. To create this option, use docker run -u \"$(id -u):$(id -g)\" -v \"$(pwd)\":/keys authelia/authelia:latest authelia rsa generate --dir /keys to generate both the private and public key in the current directory. You can then paste the private key into your configuration. Should be defined using a secret which is the recommended for containerized deployments. access_token_lifespan . type: duration . default: 1h . required: no . The maximum lifetime of an access token. It’s generally recommended keeping this short similar to the default. For more information read these docs about token lifespan. authorize_code_lifespan . type: duration . default: 1m . required: no . The maximum lifetime of an authorize code. This can be rather short, as the authorize code should only be needed to obtain the other token types. For more information read these docs about token lifespan. id_token_lifespan . type: duration . default: 1h . required: no . The maximum lifetime of an ID token. For more information read these docs about token lifespan. refresh_token_lifespan . type: string . default: 90m . required: no . The maximum lifetime of a refresh token. The refresh token can be used to obtain new refresh tokens as well as access tokens or id tokens with an up-to-date expiration. For more information read these docs about token lifespan. A good starting point is 50% more or 30 minutes more (which ever is less) time than the highest lifespan out of the access token lifespan, the authorize code lifespan, and the id token lifespan. For instance the default for all of these is 60 minutes, so the default refresh token lifespan is 90 minutes. enable_client_debug_messages . type: boolean . default: false . required: no . Allows additional debug messages to be sent to the clients. minimum_parameter_entropy . type: integer . default: 8 . required: no . This controls the minimum length of the nonce and state parameters. Security Notice: Changing this value is generally discouraged, reducing it from the default can theoretically make certain scenarios less secure. It is highly encouraged that if your OpenID Connect RP does not send these parameters or sends parameters with a lower length than the default that they implement a change rather than changing this value. clients . A list of clients to configure. The options for each client are described below. id . type: string . required: yes . The Client ID for this client. It must exactly match the Client ID configured in the application consuming this client. description . type: string . default: same as id . required: no . A friendly description for this client shown in the UI. This defaults to the same as the ID. secret . type: string . required: situational . The shared secret between Authelia and the application consuming this client. This secret must match the secret configured in the application. Currently this is stored in plain text. You must generate this option yourself. This must be provided when the client is a confidential client type, and must be blank when using the public client type. To set the client type to public see the public configuration option. public . type: bool . default: false . required: no . This enables the public client type for this client. This is for clients that are not capable of maintaining confidentiality of credentials, you can read more about client types in RFC6749. This is particularly useful for SPA’s and CLI tools. This option requires setting the client secret to a blank string. In addition to the standard rules for redirect URIs, public clients can use the urn:ietf:wg:oauth:2.0:oob redirect URI. authorization_policy . type: string . default: two_factor . required: no . The authorization policy for this client: either one_factor or two_factor. audience . type: list(string) . required: no . A list of audiences this client is allowed to request. scopes . type: list(string) . default: openid, groups, profile, email . required: no . A list of scopes to allow this client to consume. See scope definitions for more information. The documentation for the application you want to use with Authelia will most-likely provide you with the scopes to allow. redirect_uris . type: list(string) . required: yes . A list of valid callback URIs this client will redirect to. All other callbacks will be considered unsafe. The URIs are case-sensitive and they differ from application to application - the community has provided a list of URL´s for common applications. Some restrictions that have been placed on clients and their redirect URIs are as follows: . | If a client attempts to authorize with Authelia and its redirect URI is not listed in the client configuration the attempt to authorize wil fail and an error will be generated. | The redirect URIs are case-sensitive. | The URI must include a scheme and that scheme must be one of http or https. | The client can ignore rule 3 and use urn:ietf:wg:oauth:2.0:oob if it is a public client type. | . grant_types . type: list(string) . default: refresh_token, authorization_code . required: no . A list of grant types this client can return. It is recommended that this isn’t configured at this time unless you know what you’re doing. Valid options are: implicit, refresh_token, authorization_code, password, client_credentials. response_types . type: list(string) . default: code . required: no . A list of response types this client can return. It is recommended that this isn’t configured at this time unless you know what you’re doing. Valid options are: code, code id_token, id_token, token id_token, token, token id_token code. response_modes . type: list(string) . default: form_post, query, fragment . required: no . A list of response modes this client can return. It is recommended that this isn’t configured at this time unless you know what you’re doing. Potential values are form_post, query, and fragment. userinfo_signing_algorithm . type: string . default: none . required: no . The algorithm used to sign the userinfo endpoint responses. This can either be none or RS256. ",
    "url": "/docs/configuration/identity-providers/oidc.html#options",
    "relUrl": "/configuration/identity-providers/oidc.html#options"
  },"150": {
    "doc": "OpenID Connect",
    "title": "Generating a random secret",
    "content": "If you must provide a random secret in configuration, you can generate a random string of sufficient length. The command . LENGTH=64 tr -cd '[:alnum:]' &lt; /dev/urandom | fold -w \"${LENGTH}\" | head -n 1 | tr -d '\\n' ; echo . prints such a string with a length in characters of ${LENGTH} on stdout. The string will only contain alphanumeric characters. For Kubernetes, see this section too. ",
    "url": "/docs/configuration/identity-providers/oidc.html#generating-a-random-secret",
    "relUrl": "/configuration/identity-providers/oidc.html#generating-a-random-secret"
  },"151": {
    "doc": "OpenID Connect",
    "title": "Scope Definitions",
    "content": "openid . This is the default scope for openid. This field is forced on every client by the configuration validation that Authelia does. | JWT Field | JWT Type | Authelia Attribute | Description | . | sub | string | Username | The username the user used to login with | . | scope | string | scopes | Granted scopes (space delimited) | . | scp | array[string] | scopes | Granted scopes | . | iss | string | hostname | The issuer name, determined by URL | . | at_hash | string | N/A | Access Token Hash | . | aud | array[string] | N/A | Audience | . | exp | number | N/A | Expires | . | auth_time | number | N/A | The time the user authenticated with Authelia | . | rat | number | N/A | The time when the token was requested | . | iat | number | N/A | The time when the token was issued | . | jti | string(uuid) | N/A | JWT Identifier | . groups . This scope includes the groups the authentication backend reports the user is a member of in the token. | JWT Field | JWT Type | Authelia Attribute | Description | . | groups | array[string] | Groups | The users display name | . email . This scope includes the email information the authentication backend reports about the user in the token. | JWT Field | JWT Type | Authelia Attribute | Description | . | email | string | email[0] | The first email address in the list of emails | . | email_verified | bool | N/A | If the email is verified, assumed true for the time being | . | alt_emails | array[string] | email[1:] | All email addresses that are not in the email JWT field | . profile . This scope includes the profile information the authentication backend reports about the user in the token. | JWT Field | JWT Type | Authelia Attribute | Description | . | name | string | display_name | The users display name | . ",
    "url": "/docs/configuration/identity-providers/oidc.html#scope-definitions",
    "relUrl": "/configuration/identity-providers/oidc.html#scope-definitions"
  },"152": {
    "doc": "OpenID Connect",
    "title": "Endpoint Implementations",
    "content": "This is a table of the endpoints we currently support and their paths. This can be requrired information for some RP’s, particularly those that don’t use discovery. The paths are appended to the end of the primary URL used to access Authelia. For example in the Discovery example provided you access Authelia via https://auth.example.com, the discovery URL is https://auth.example.com/.well-known/openid-configuration. | Endpoint | Path | . | Discovery | .well-known/openid-configuration | . | JWKS | api/oidc/jwks | . | Authorization | api/oidc/authorize | . | Token | api/oidc/token | . | Introspection | api/oidc/introspect | . | Revocation | api/oidc/revoke | . | Userinfo | api/oidc/userinfo | . ",
    "url": "/docs/configuration/identity-providers/oidc.html#endpoint-implementations",
    "relUrl": "/configuration/identity-providers/oidc.html#endpoint-implementations"
  },"153": {
    "doc": "Time-based One-Time Password",
    "title": "Time-based One-Time Password",
    "content": "Authelia uses time-based one-time passwords as the OTP method. You have the option to tune the settings of the TOTP generation, and you can see a full example of TOTP configuration below, as well as sections describing them. ",
    "url": "/docs/configuration/one-time-password.html",
    "relUrl": "/configuration/one-time-password.html"
  },"154": {
    "doc": "Time-based One-Time Password",
    "title": "Configuration",
    "content": "totp: issuer: authelia.com algorithm: sha1 digits: 6 period: 30 skew: 1 . ",
    "url": "/docs/configuration/one-time-password.html#configuration",
    "relUrl": "/configuration/one-time-password.html#configuration"
  },"155": {
    "doc": "Time-based One-Time Password",
    "title": "Options",
    "content": "issuer . type: string . default: Authelia . required: no . Applications generating one-time passwords usually display an issuer to differentiate applications registered by the user. Authelia allows customisation of the issuer to differentiate the entry created by Authelia from others. algorithm . type: string . default: sha1 . required: no . Important Note: Many TOTP applications do not support this option. It is strongly advised you find out which applications your users use and test them before changing this option. It is insufficient to test that the application can add the key, it must also authenticate with Authelia as some applications silently ignore these options. Bitwarden is the only one that has been tested at this time. If you’d like to contribute to documenting support for this option please see Issue 2650. The algorithm used for the TOTP key. Possible Values (case-insensitive): . | sha1 | sha256 | sha512 | . Changing this value only affects newly registered TOTP keys. See the Registration section for more information. digits . type: integer . default: 6 . required: no . Important Note: Some TOTP applications do not support this option. It is strongly advised you find out which applications your users use and test them before changing this option. It is insufficient to test that the application can add the key, it must also authenticate with Authelia as some applications silently ignore these options. Bitwarden is the only one that has been tested at this time. If you’d like to contribute to documenting support for this option please see Issue 2650. The number of digits a user needs to input to perform authentication. It’s generally not recommended for this to be altered as many TOTP applications do not support anything other than 6. What’s worse is some TOTP applications allow you to add the key, but do not use the correct number of digits specified by the key. The valid values are 6 or 8. Changing this value only affects newly registered TOTP keys. See the Registration section for more information. period . type: integer . default: 30 . required: no . The period of time in seconds between key rotations or the time element of TOTP. Please see the input validation section for how this option and the skew option interact with each other. It is recommended to keep this value set to 30, the minimum is 15. Changing this value only affects newly registered TOTP keys. See the Registration section for more information. skew . type: integer . default: 1 . required: no . The number of one time passwords either side of the current valid one time password that should also be considered valid. The default of 1 results in 3 one time passwords valid. A setting of 2 would result in 5. With the default period of 30 this would result in 90 and 150 seconds of valid one time passwords respectively. Please see the input validation section for how this option and the period option interact with each other. Changing this value affects all TOTP validations, not just newly registered ones. ",
    "url": "/docs/configuration/one-time-password.html#options",
    "relUrl": "/configuration/one-time-password.html#options"
  },"156": {
    "doc": "Time-based One-Time Password",
    "title": "Registration",
    "content": "When users register their TOTP device for the first time, the current issuer, algorithm, and period are used to generate the TOTP link and QR code. These values are saved to the database for future validations. This means if the configuration options are changed, users will not need to regenerate their keys. This functionality takes effect from 4.33.0 onwards, previously the effect was the keys would just fail to validate. If you’d like to force users to register a new device, you can delete the old device for a particular user by using the authelia storage totp delete &lt;username&gt; command regardless of if you change the settings or not. ",
    "url": "/docs/configuration/one-time-password.html#registration",
    "relUrl": "/configuration/one-time-password.html#registration"
  },"157": {
    "doc": "Time-based One-Time Password",
    "title": "Input Validation",
    "content": "The period and skew configuration parameters affect each other. The default values are a period of 30 and a skew of 1. It is highly recommended you do not change these unless you wish to set skew to 0. The way you configure these affects security by changing the length of time a one-time password is valid for. The formula to calculate the effective validity period is period + (period * skew * 2). For example period 30 and skew 1 would result in 90 seconds of validity, and period 30 and skew 2 would result in 150 seconds of validity. ",
    "url": "/docs/configuration/one-time-password.html#input-validation",
    "relUrl": "/configuration/one-time-password.html#input-validation"
  },"158": {
    "doc": "Time-based One-Time Password",
    "title": "System time accuracy",
    "content": "It’s important to note that if the system time is not accurate enough then clients will seemingly not generate valid passwords for TOTP. Conversely this is the same when the client time is not accurate enough. This is due to the Time-based One Time Passwords being time-based. Authelia by default checks the system time against an NTP server on startup. This helps to prevent a time synchronization issue on the server being an issue. There is however no effective and reliable way to check the clients. ",
    "url": "/docs/configuration/one-time-password.html#system-time-accuracy",
    "relUrl": "/configuration/one-time-password.html#system-time-accuracy"
  },"159": {
    "doc": "Time-based One-Time Password",
    "title": "Encryption",
    "content": "The TOTP secret is encrypted in the database in version 4.33.0 and above. This is so a user having access to only the database cannot easily compromise your two-factor authentication method. This may be inconvenient for some users who wish to export TOTP keys from Authelia to other services. As such there is a command specifically for exporting TOTP configurations from the database. These commands require the configuration or at least a minimal configuration that has the storage backend connection details and the encryption key. Export in Key URI Format: . $ authelia storage totp export --format uri . Export as CSV: . $ authelia storage totp export --format csv . Help: . $ authelia storage totp export --help . ",
    "url": "/docs/configuration/one-time-password.html#encryption",
    "relUrl": "/configuration/one-time-password.html#encryption"
  },"160": {
    "doc": "Time-based One-Time Password",
    "title": "Time-based One-Time Password",
    "content": "Authelia supports Time-base one-time password generated by apps like Google Authenticator. After having successfully completed the first factor, select One-Time Password method option and click on Register device link. This will e-mail you to confirm your identity. NOTE: If you’re testing Authelia, this e-mail has likely been sent to the mailbox available at https://mail.example.com:8080/ . Once this validation step is completed, a QR Code gets displayed. You can then use Google Authenticator to scan the code in order to register your device. From now on, you get tokens generated every 30 seconds that you can use to validate the second factor in Authelia. ",
    "url": "/docs/features/2fa/one-time-password.html",
    "relUrl": "/features/2fa/one-time-password.html"
  },"161": {
    "doc": "Time-based One-Time Password",
    "title": "Limitations",
    "content": "Users currently can only enroll a single TOTP device in Authelia. Multiple single type device enrollment will be available when this issue has been resolved. ",
    "url": "/docs/features/2fa/one-time-password.html#limitations",
    "relUrl": "/features/2fa/one-time-password.html#limitations"
  },"162": {
    "doc": "Password Reset",
    "title": "Password Reset",
    "content": "Authelia provides a workflow to let users reset their password when they lose it. To disable reset password functionality please see the configuration docs. A simple click on Reset password? for starting the process. Note that resetting a password requires a new identity verification using the e-mail of the user. Give your username and receive an e-mail to verify your identity. Once your identity has been verified, fill in the form to reset your password. Now you can authenticate with your new credentials. ",
    "url": "/docs/features/password-reset.html",
    "relUrl": "/features/password-reset.html"
  },"163": {
    "doc": "PostgreSQL",
    "title": "PostgreSQL",
    "content": "The PostgreSQL storage provider. ",
    "url": "/docs/configuration/storage/postgres.html",
    "relUrl": "/configuration/storage/postgres.html"
  },"164": {
    "doc": "PostgreSQL",
    "title": "Configuration",
    "content": "storage: encryption_key: a_very_important_secret postgres: host: 127.0.0.1 port: 5432 database: authelia schema: public username: authelia password: mypassword ssl: mode: disable root_certificate: /path/to/root_cert.pem certificate: /path/to/cert.pem key: /path/to/key.pem . ",
    "url": "/docs/configuration/storage/postgres.html#configuration",
    "relUrl": "/configuration/storage/postgres.html#configuration"
  },"165": {
    "doc": "PostgreSQL",
    "title": "Options",
    "content": "encryption_key . See the encryption_key docs. host . type: string . required: yes . The database server host. If utilising an IPv6 literal address it must be enclosed by square brackets and quoted: . host: \"[fd00:1111:2222:3333::1]\" . port . type: integer . default: 5432 . required: no . The port the database server is listening on. database . type: string . required: yes . The database name on the database server that the assigned user has access to for the purpose of Authelia. schema . type: string . default: public . required: no . The database schema name to use on the database server that the assigned user has access to for the purpose of Authelia. By default this is the public schema. username . type: string . required: yes . The username paired with the password used to connect to the database. password . type: string . required: yes . The password paired with the username used to connect to the database. Can also be defined using a secret which is also the recommended way when running as a container. timeout . type: duration . default: 5s . required: no . The SQL connection timeout. ssl . mode . type: string . default: disable . required: no . SSL mode configures how to handle SSL connections with Postgres. Valid options are ‘disable’, ‘require’, ‘verify-ca’, or ‘verify-full’. See the PostgreSQL Documentation or pgx - PostgreSQL Driver and Toolkit Documentation for more information. root_certificate . type: string . required: no . The optional location of the root certificate file encoded in the PEM format for validation purposes. certificate . type: string . required: no . The optional location of the certificate file encoded in the PEM format for validation purposes. key . type: string . required: no . The optional location of the key file encoded in the PEM format for authentication purposes. ",
    "url": "/docs/configuration/storage/postgres.html#options",
    "relUrl": "/configuration/storage/postgres.html#options"
  },"166": {
    "doc": "Push Notification",
    "title": "Mobile Push Notification",
    "content": "Mobile push notifications is the new trendy second factor method. When second factor is requested by Authelia, a notification is sent on your phone that you can either accept or deny. Authelia leverages Duo third party to provide this feature. First, sign up on their website, log in, create a user account and attach it a mobile device. Beware that the name of the user must match the name of the user in Authelia. Then, in Duo interface, click on Applications and Protect an Application. Select the option Partner Auth API. This will generate an integration key, a secret key and a hostname. You can set the name of the application to Authelia and then you must add the generated information to Authelia configuration as shown below: . duo_api: hostname: api-123456789.example.com integration_key: ABCDEF secret_key: 1234567890abcdefghifjkl . Now that Authelia is configured, pass the first factor and select the Push notification option. You should now receive a notification on your mobile phone with all the details about the authentication request. In case you have multiple devices available, you will be asked to select your preferred device. ",
    "url": "/docs/features/2fa/push-notifications.html#mobile-push-notification",
    "relUrl": "/features/2fa/push-notifications.html#mobile-push-notification"
  },"167": {
    "doc": "Push Notification",
    "title": "Limitation",
    "content": "Users must be enrolled via the Duo Admin panel, they cannot enroll a device from Authelia yet. ",
    "url": "/docs/features/2fa/push-notifications.html#limitation",
    "relUrl": "/features/2fa/push-notifications.html#limitation"
  },"168": {
    "doc": "Push Notification",
    "title": "FAQ",
    "content": "Why don’t I have access to the Push Notification option? . It’s likely that you have not configured Authelia correctly. Please read this documentation again and be sure you had a look at config.template.yml. ",
    "url": "/docs/features/2fa/push-notifications.html#faq",
    "relUrl": "/features/2fa/push-notifications.html#faq"
  },"169": {
    "doc": "Push Notification",
    "title": "Push Notification",
    "content": " ",
    "url": "/docs/features/2fa/push-notifications.html",
    "relUrl": "/features/2fa/push-notifications.html"
  },"170": {
    "doc": "Redis",
    "title": "Redis",
    "content": "This is a session provider. By default Authelia uses an in-memory provider. Not configuring redis leaves Authelia stateful. It’s important in highly available scenarios to configure this option and we highly recommend it in production environments. It requires you setup redis as well. ",
    "url": "/docs/configuration/session/redis.html",
    "relUrl": "/configuration/session/redis.html"
  },"171": {
    "doc": "Redis",
    "title": "Configuration",
    "content": "session: redis: host: 127.0.0.1 port: 6379 username: authelia password: authelia database_index: 0 maximum_active_connections: 8 minimum_idle_connections: 0 tls: server_name: myredis.example.com skip_verify: false minimum_version: TLS1.2 high_availability: sentinel_name: mysentinel # If `sentinel_username` is supplied, Authelia will connect using ACL-based # authentication. Otherwise, it will use traditional `requirepass` auth. sentinel_username: sentinel_user sentinel_password: sentinel_specific_pass nodes: - host: sentinel-node1 port: 26379 - host: sentinel-node2 port: 26379 route_by_latency: false route_randomly: false . ",
    "url": "/docs/configuration/session/redis.html#configuration",
    "relUrl": "/configuration/session/redis.html#configuration"
  },"172": {
    "doc": "Redis",
    "title": "Options",
    "content": "host . type: string . required: yes . The redis host or unix socket path. If utilising an IPv6 literal address it must be enclosed by square brackets and quoted: . host: \"[fd00:1111:2222:3333::1]\" . port . type: integer . default: 6379 . required: no . The port redis is listening on. username . type: string . required: no . The username for redis authentication. Only supported in redis 6.0+, and redis currently offers backwards compatibility with password-only auth. You probably do not need to set this unless you went through the process of setting up redis ACLs. password . type: string . required: no . The password for redis authentication. database_index . type: integer . default: 0 . required: no . The index number of the redis database, the same value as specified with the redis SELECT command. maximum_active_connections . type: integer . default: 8 . required: no . The maximum connections open to redis at the same time. minimum_idle_connections . type: integer . default: 0 . required: no . The minimum number of redis connections to keep open as long as they don’t exceed the maximum active connections. This is useful if there are long delays in establishing connections. tls . If defined enables redis over TLS, and additionally controls the TLS connection validation process. You can see how to configure the tls section here. high_availability . When defining this session it enables redis sentinel connections. It’s possible in the future we may add redis cluster. sentinel_name . type: string . required: yes . The redis sentinel master name. This is defined in your redis sentinel configuration, it is not a hostname. This must be defined currently for a high availability configuration. sentinel_username . type: string . required: no . The username for the redis sentinel connection. If this is provided, it will be used along with the sentinel_password for ACL-based authentication to the Redis Sentinel. If only a password is provided, the redis sentinel connection will be authenticated with traditional requirepass authentication. sentinel_password . type: string . required: no (yes if sentinel_username is supplied) . The password for the redis sentinel connection. If specified with sentinel_username, configures Authelia to authenticate to the Redis Sentinel with ACL-based authentication. Otherwise, this is used for requirepass authentication. nodes . A list of redis sentinel nodes to load balance over. This list is added to the host in the redis section above. It is required you either define the redis host or one redis sentinel node. The redis host must be a redis sentinel host, not a regular one. The individual redis hosts are determined using redis sentinel commands. Each node has a host and port configuration. Example: . - host: redis-sentinel-0 port: 26379 . host . type: boolean . default: false . required: no . The host of this redis sentinel node. port . type: integer . default: 26379 . required: no . The port of this redis sentinel node. route_by_latency . type: boolean . default: false . required: no . Prioritizes low latency redis sentinel nodes when set to true. route_randomly . type: boolean . default: false . required: no . Randomly chooses redis sentinel nodes when set to true. ",
    "url": "/docs/configuration/session/redis.html#options",
    "relUrl": "/configuration/session/redis.html#options"
  },"173": {
    "doc": "Regulation",
    "title": "Regulation",
    "content": "Authelia takes the security of users very seriously and comes with a way to avoid brute-forcing the first factor credentials by regulating the authentication attempts and temporarily banning an account when too many attempts have been made. ",
    "url": "/docs/features/regulation.html",
    "relUrl": "/features/regulation.html"
  },"174": {
    "doc": "Regulation",
    "title": "Configuration",
    "content": "Please check the dedicated documentation. ",
    "url": "/docs/features/regulation.html#configuration",
    "relUrl": "/features/regulation.html#configuration"
  },"175": {
    "doc": "Regulation",
    "title": "Regulation",
    "content": "Authelia can temporarily ban accounts when there are too many authentication attempts. This helps prevent brute-force attacks. ",
    "url": "/docs/configuration/regulation.html",
    "relUrl": "/configuration/regulation.html"
  },"176": {
    "doc": "Regulation",
    "title": "Configuration",
    "content": "regulation: max_retries: 3 find_time: 2m ban_time: 5m . ",
    "url": "/docs/configuration/regulation.html#configuration",
    "relUrl": "/configuration/regulation.html#configuration"
  },"177": {
    "doc": "Regulation",
    "title": "Options",
    "content": "max_retries . type: integer . default: 3 . required: no . The number of failed login attempts before a user may be banned. Setting this option to 0 disables regulation entirely. find_time . type: string (duration) . default: 2m . required: no . The period of time in duration notation format analyzed for failed attempts. For example if you set max_retries to 3 and find_time to 2m this means the user must have 3 failed logins in 2 minutes. ban_time . type: string (duration) . default: 5m . required: no . The period of time in duration notation format the user is banned for after meeting the max_retries and find_time configuration. After this duration the account will be able to login again. ",
    "url": "/docs/configuration/regulation.html#options",
    "relUrl": "/configuration/regulation.html#options"
  },"178": {
    "doc": "Roadmap",
    "title": "Roadmap",
    "content": "Currently the team consists of 3 globally distributed developers working actively on improving Authelia in our spare time and we define our priorities based on a roadmap that we share here for transparency. We also try to balance features and improvements as much as possible with the maintenance tasks we have to perform to keep the backlog of open issues in a reasonable state. If you’re willing to contribute and help us move forward faster, get in touch with us on Matrix. We’ll be glad to share ideas and plans with you. Below are the prioritised roadmap items: . | In Preview this roadmap item is in preview status, more information can be found in the docs. Authelia acts as an OpenID Connect Provider. This is a high priority because currently the only way to pass authentication information back to the protected app is through the use of HTTP headers as described here however, many apps either do not support this method or are starting to move away from this in favour of OpenID Connect or OAuth2 internally or via plugins. | Administration interface. This is useful in many cases to properly manage users and administrate activities like unbanning banned users. In the future we can even think of adding/removing users from there, request a password reset for a user or all users, request a 2FA enrollment, temporarily block users, etc… . | User interface. This will help the users manage their 2FA devices, reset their password, review their authentication activity. In the future we envisage users will be able to customize their profile with an avatar, set their preferences regarding 2FA and according to the global policy defined by administrators, etc… . | Facilitate setup on Kubernetes. There are mainly two objectives here. First, we need to provide the documentation required to setup Authelia on Kubernetes. Even though, some users already have it working and the feature is even tested in the project, there is a clear lack of documentation. The second item is to provide a Helm chart to streamline the setup on Kubernetes. | . ",
    "url": "/docs/roadmap.html",
    "relUrl": "/roadmap.html"
  },"179": {
    "doc": "Secrets",
    "title": "Secrets",
    "content": "Configuration of Authelia requires some secrets and passwords. Even if they can be set in the configuration file or standard environment variables, the recommended way to set secrets is to use environment variables as described below. ",
    "url": "/docs/configuration/secrets.html",
    "relUrl": "/configuration/secrets.html"
  },"180": {
    "doc": "Secrets",
    "title": "Environment variables",
    "content": "A secret value can be loaded by Authelia when the configuration key ends with one of the following words: key, secret, password, or token. If you take the expected environment variable for the configuration option with the _FILE suffix at the end. The value of these environment variables must be the path of a file that is readable by the Authelia process, if they are not, Authelia will fail to load. Authelia will automatically remove the newlines from the end of the files contents. For instance the LDAP password can be defined in the configuration at the path authentication_backend.ldap.password, so this password could alternatively be set using the environment variable called AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE. Here is the list of the environment variables which are considered secrets and can be defined. Please note that only secrets can be loaded into the configuration if they end with one of the suffixes above, you can set the value of any other configuration using the environment but instead of loading a file the value of the environment variable is used. | Configuration Key | Environment Variable | . | tls_key | AUTHELIA_TLS_KEY_FILE | . | jwt_secret | AUTHELIA_JWT_SECRET_FILE | . | duo_api.secret_key | AUTHELIA_DUO_API_SECRET_KEY_FILE | . | session.secret | AUTHELIA_SESSION_SECRET_FILE | . | session.redis.password | AUTHELIA_SESSION_REDIS_PASSWORD_FILE | . | session.redis.high_availability.sentinel_password | AUTHELIA_REDIS_HIGH_AVAILABILITY_SENTINEL_PASSWORD_FILE | . | storage.encryption_key | AUTHELIA_STORAGE_ENCRYPTION_KEY_FILE | . | storage.mysql.password | AUTHELIA_STORAGE_MYSQL_PASSWORD_FILE | . | storage.postgres.password | AUTHELIA_STORAGE_POSTGRES_PASSWORD_FILE | . | notifier.smtp.password | AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE | . | authentication_backend.ldap.password | AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE | . | identity_providers.oidc.issuer_private_key | AUTHELIA_IDENTITY_PROVIDERS_OIDC_ISSUER_PRIVATE_KEY_FILE | . | identity_providers.oidc.hmac_secret | AUTHELIA_IDENTITY_PROVIDERS_OIDC_HMAC_SECRET_FILE | . ",
    "url": "/docs/configuration/secrets.html#environment-variables",
    "relUrl": "/configuration/secrets.html#environment-variables"
  },"181": {
    "doc": "Secrets",
    "title": "Secrets in configuration file",
    "content": "If for some reason you decide on keeping the secrets in the configuration file, it is strongly recommended that you ensure the permissions of the configuration file are appropriately set so that other users or processes cannot access this file. Generally the UNIX permissions that are appropriate are 0600. ",
    "url": "/docs/configuration/secrets.html#secrets-in-configuration-file",
    "relUrl": "/configuration/secrets.html#secrets-in-configuration-file"
  },"182": {
    "doc": "Secrets",
    "title": "Secrets exposed in an environment variable",
    "content": "In all versions 4.30.0+ you can technically set secrets using the environment variables without the _FILE suffix by setting the value to the value you wish to set in configuration, however we strongly urge people not to use this option and instead use the file-based secrets above. Prior to implementing file secrets the only way you were able to define secret values was either via configuration or via environment variables in plain text. See this article for reasons why setting them via the file counterparts is highly encouraged. ",
    "url": "/docs/configuration/secrets.html#secrets-exposed-in-an-environment-variable",
    "relUrl": "/configuration/secrets.html#secrets-exposed-in-an-environment-variable"
  },"183": {
    "doc": "Secrets",
    "title": "Docker",
    "content": "Secrets can be provided in a docker-compose.yml either with Docker secrets or bind mounted secret files, examples of these are provided below. Compose with Docker secrets . This example assumes secrets are stored in /path/to/authelia/secrets/{secretname} on the host and are exposed with Docker secrets in a docker-compose.yml file: . version: '3.8' networks: net: driver: bridge secrets: jwt: file: /path/to/authelia/secrets/jwt duo: file: /path/to/authelia/secrets/duo session: file: /path/to/authelia/secrets/session redis: file: /path/to/authelia/secrets/redis mysql: file: /path/to/authelia/secrets/mysql smtp: file: /path/to/authelia/secrets/smtp ldap: file: /path/to/authelia/secrets/ldap services: authelia: image: authelia/authelia container_name: authelia secrets: - jwt - duo - session - redis - mysql - smtp - ldap volumes: - /path/to/authelia:/config networks: - net expose: - 9091 restart: unless-stopped environment: - AUTHELIA_JWT_SECRET_FILE=/run/secrets/jwt - AUTHELIA_DUO_API_SECRET_KEY_FILE=/run/secrets/duo - AUTHELIA_SESSION_SECRET_FILE=/run/secrets/session - AUTHELIA_SESSION_REDIS_PASSWORD_FILE=/run/secrets/redis - AUTHELIA_STORAGE_MYSQL_PASSWORD_FILE=/run/secrets/mysql - AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE=/run/secrets/smtp - AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE=/run/secrets/ldap - TZ=Australia/Melbourne . Compose with bind mounted secret files . This example assumes secrets are stored in /path/to/authelia/secrets/{secretname} on the host and are exposed with bind mounted secret files in a docker-compose.yml file at /config/secrets/: . version: '3.8' networks: net: driver: bridge services: authelia: image: authelia/authelia container_name: authelia volumes: - /path/to/authelia:/config networks: - net expose: - 9091 restart: unless-stopped environment: - AUTHELIA_JWT_SECRET_FILE=/config/secrets/jwt - AUTHELIA_DUO_API_SECRET_KEY_FILE=/config/secrets/duo - AUTHELIA_SESSION_SECRET_FILE=/config/secrets/session - AUTHELIA_SESSION_REDIS_PASSWORD_FILE=/config/secrets/redis - AUTHELIA_STORAGE_MYSQL_PASSWORD_FILE=/config/secrets/mysql - AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE=/config/secrets/smtp - AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE=/config/secrets/ldap - TZ=Australia/Melbourne . ",
    "url": "/docs/configuration/secrets.html#docker",
    "relUrl": "/configuration/secrets.html#docker"
  },"184": {
    "doc": "Secrets",
    "title": "Kubernetes",
    "content": "Secrets can be mounted as files using the following sample manifests. To create a secret, the following manifest can be used . --- kind: Secret apiVersion: v1 metadata: name: a-nice-name namespace: your-authelia-namespace data: duo_key: &gt;- UXE1WmM4S0pldnl6eHRwQ3psTGpDbFplOXFueUVyWEZhYjE0Z01IRHN0RT0K jwt_secret: &gt;- anotherBase64EncodedSecret ... where UXE1WmM4S0pldnl6eHRwQ3psTGpDbFplOXFueUVyWEZhYjE0Z01IRHN0RT0K is Base64 encoded for Qq5Zc8KJevyzxtpCzlLjClZe9qnyErXFab14gMHDstE, the actual content of the secret. You can generate these contents with . LENGTH=64 tr -cd '[:alnum:]' &lt; /dev/urandom \\ | fold -w \"${LENGTH}\" \\ | head -n 1 \\ | tr -d '\\n' \\ | tee actualSecretContent.txt \\ | base64 --wrap 0 \\ ; echo . which writes the secret’s content to the actualSecretContent.txt file and print the Base64 encoded version on stdout. ${LENGTH} is the length in characters of the secret content generated by this pipe. If you don’t want the contents to be written to actualSecretContent.txt, just delete the line with the tee command. Kustomization . | Filename: ./kustomization.yaml | Command: kubectl apply -k | Notes: this kustomization expects the Authelia configuration.yml in the same directory. You will need to edit the kustomization.yaml with your desired secrets after the equal signs. If you change the value before the equal sign you’ll have to adjust the volumes section of the daemonset template (or deployment template if you’re using it). | . #filename: ./kustomization.yaml generatorOptions: disableNameSuffixHash: true labels: type: generated app: authelia configMapGenerator: - name: authelia files: - configuration.yml secretGenerator: - name: authelia literals: - jwt_secret=myverysecuresecret - session_secret=mysessionsecret - redis_password=myredispassword - sql_password=mysqlpassword - ldap_password=myldappassword - duo_secret=myduosecretkey - smtp_password=mysmtppassword . DaemonSet . | Filename: ./daemonset.yaml | Command: kubectl apply -f ./daemonset.yaml | Notes: assumes Kubernetes API 1.16 or greater #filename: daemonset.yaml #command: kubectl apply -f daemonset.yaml #notes: assumes kubernetes api 1.16+ apiVersion: apps/v1 kind: DaemonSet metadata: name: authelia namespace: authelia labels: app: authelia spec: selector: matchLabels: app: authelia updateStrategy: type: RollingUpdate template: metadata: labels: app: authelia spec: containers: - name: authelia image: authelia/authelia:latest imagePullPolicy: IfNotPresent env: - name: AUTHELIA_JWT_SECRET_FILE value: /app/secrets/jwt - name: AUTHELIA_DUO_API_SECRET_KEY_FILE value: /app/secrets/duo - name: AUTHELIA_SESSION_SECRET_FILE value: /app/secrets/session - name: AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD_FILE value: /app/secrets/ldap_password - name: AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE value: /app/secrets/smtp_password - name: AUTHELIA_STORAGE_MYSQL_PASSWORD_FILE value: /app/secrets/sql_password - name: AUTHELIA_SESSION_REDIS_PASSWORD_FILE value: /app/secrets/redis_password - name: TZ value: America/Toronto ports: - name: authelia-port containerPort: 9091 startupProbe: httpGet: path: /api/state port: authelia-port initialDelaySeconds: 15 timeoutSeconds: 5 periodSeconds: 5 failureThreshold: 4 livenessProbe: httpGet: path: /api/state port: authelia-port initialDelaySeconds: 60 timeoutSeconds: 5 periodSeconds: 30 failureThreshold: 2 readinessProbe: httpGet: path: /api/state port: authelia-port initialDelaySeconds: 15 timeoutSeconds: 5 periodSeconds: 5 failureThreshold: 5 volumeMounts: - mountPath: /config name: config-volume - mountPath: /app/secrets name: secrets readOnly: true volumes: - name: config-volume configMap: name: authelia items: - key: configuration.yml path: configuration.yml - name: secrets secret: secretName: authelia items: - key: jwt_secret path: jwt - key: duo_secret path: duo - key: session_secret path: session - key: redis_password path: redis_password - key: sql_password path: sql_password - key: ldap_password path: ldap_password - key: smtp_password path: smtp_password . | . ",
    "url": "/docs/configuration/secrets.html#kubernetes",
    "relUrl": "/configuration/secrets.html#kubernetes"
  },"185": {
    "doc": "Security Keys",
    "title": "Security Keys",
    "content": "Authelia supports hardware-based second factors leveraging security keys like YubiKey’s. Security keys are among the most secure second factor. This method is already supported by many major applications and platforms like Google, Facebook, Github, some banks, and much more… . Normally, the protocol requires your security key to be enrolled on each site before being able to authenticate with it. Since Authelia provides Single Sign-On, your users will need to enroll their device only once to get access to all your applications. After having successfully passed the first factor, select Security Key method and click on Register device link. This will send you an email to verify your identity. NOTE: This e-mail has likely been sent to the mailbox at https://mail.example.com:8080/ if you’re testing Authelia. Confirm your identity by clicking on Register and you’ll be asked to touch the token of your security key to complete the enrollment. Upon successful enrollment, you can authenticate using your security key by simply touching the token again when requested: . Easy, right?! . ",
    "url": "/docs/features/2fa/security-key.html",
    "relUrl": "/features/2fa/security-key.html"
  },"186": {
    "doc": "Security Keys",
    "title": "Limitations",
    "content": "Users currently can only enroll a single U2F device in Authelia. Multiple single type device enrollment will be available when this issue has been resolved. ",
    "url": "/docs/features/2fa/security-key.html#limitations",
    "relUrl": "/features/2fa/security-key.html#limitations"
  },"187": {
    "doc": "Security Keys",
    "title": "FAQ",
    "content": "Why don’t I have access to the Security Key option? . U2F protocol is a new protocol that is only supported by recent browsers and might even be enabled on some of them. Please be sure your browser supports U2F and that the feature is enabled to make the option available in Authelia. ",
    "url": "/docs/features/2fa/security-key.html#faq",
    "relUrl": "/features/2fa/security-key.html#faq"
  },"188": {
    "doc": "Server",
    "title": "Server",
    "content": "The server section configures and tunes the http server module Authelia uses. ",
    "url": "/docs/configuration/server.html",
    "relUrl": "/configuration/server.html"
  },"189": {
    "doc": "Server",
    "title": "Configuration",
    "content": "server: host: 0.0.0.0 port: 9091 path: \"\" read_buffer_size: 4096 write_buffer_size: 4096 enable_pprof: false enable_expvars: false disable_healthcheck: false tls: key: \"\" certificate: \"\" . ",
    "url": "/docs/configuration/server.html#configuration",
    "relUrl": "/configuration/server.html#configuration"
  },"190": {
    "doc": "Server",
    "title": "Options",
    "content": " ",
    "url": "/docs/configuration/server.html#options",
    "relUrl": "/configuration/server.html#options"
  },"191": {
    "doc": "Server",
    "title": "host",
    "content": "type: string . default: 0.0.0.0 . required: no . Defines the address to listen on. See also port. Should typically be 0.0.0.0 or 127.0.0.1, the former for containerized environments and the later for daemonized environments like init.d and systemd. Note: If utilising an IPv6 literal address it must be enclosed by square brackets and quoted: . host: \"[fd00:1111:2222:3333::1]\" . port . type: integer . default: 9091 . required: no . Defines the port to listen on. See also host. path . type: string . default: “” . required: no . Authelia by default is served from the root / location, either via its own domain or subdomain. Modifying this setting will allow you to serve Authelia out from a specified base path. Please note that currently only a single level path is supported meaning slashes are not allowed, and only alphanumeric characters are supported. Example: https://auth.example.com/, https://example.com/ . server: path: \"\" . Example: https://auth.example.com/authelia/, https://example.com/authelia/ . server: path: authelia . asset_path . type: string . default: “” . required: no . Authelia by default serves all static assets from an embedded filesystem in the Go binary. Modifying this setting will allow you to override and serve specific assets for Authelia from a specified path. All files that can be overridden are documented below and must be placed in the asset_path with a flat file structure. Example: . /config/assets/ ├── favicon.ico └── logo.png . | Asset | File name | . | Favicon | favicon.ico | . | Logo | logo.png | . read_buffer_size . type: integer . default: 4096 . required: no . Configures the maximum request size. The default of 4096 is generally sufficient for most use cases. write_buffer_size . type: integer . default: 4096 . required: no . Configures the maximum response size. The default of 4096 is generally sufficient for most use cases. enable_pprof . type: boolean . default: false . required: no . Enables the go pprof endpoints. enable_expvars . type: boolean . default: false . required: no . Enables the go expvars endpoints. disable_healthcheck . type: boolean . default: false . required: no . On startup Authelia checks for the existence of /app/healthcheck.sh and /app/.healthcheck.env and if both of these exist it writes the configuration vars for the healthcheck to the /app/.healthcheck.env file. In instances where this is not desirable it’s possible to disable these interactions entirely. An example situation where this is the case is in Kubernetes when set security policies that prevent writing to the ephemeral storage of a container or just don’t want to enable the internal health check. tls . Authelia typically listens for plain unencrypted connections. This is by design as most environments allow to security on lower areas of the OSI model. However it required, if you specify both the tls key and tls certificate options, Authelia will listen for TLS connections. key . type: string (path) . default: “” . required: situational . The path to the private key for TLS connections. Must be in DER base64/PEM format. certificate . type: string (path) . default: “” . required: situational . The path to the public certificate for TLS connections. Must be in DER base64/PEM format. ",
    "url": "/docs/configuration/server.html#host",
    "relUrl": "/configuration/server.html#host"
  },"192": {
    "doc": "Server",
    "title": "Additional Notes",
    "content": "Buffer Sizes . The read and write buffer sizes generally should be the same. This is because when Authelia verifies if the user is authorized to visit a URL, it also sends back nearly the same size response as the request. However you’re able to tune these individually depending on your needs. Asset Overrides . If replacing the Logo for your Authelia portal it is recommended to upload a transparent PNG of your desired logo. Authelia will automatically resize the logo to an appropriate size to present in the frontend. ",
    "url": "/docs/configuration/server.html#additional-notes",
    "relUrl": "/configuration/server.html#additional-notes"
  },"193": {
    "doc": "Single Factor",
    "title": "Single Factor",
    "content": "Authelia supports single factor authentication to let applications send authenticated requests to other applications. Single or two-factor authentication can be configured per resource of an application for flexibility. For instance, you can configure Authelia to grant access to all resources matching app1.example.com/api/(.*) with only a single factor and all resources matching app1.example.com/admin with two factors. To know more about the configuration of the feature, please visit the documentation about the configuration. ",
    "url": "/docs/features/single-factor.html",
    "relUrl": "/features/single-factor.html"
  },"194": {
    "doc": "Single Factor",
    "title": "HTTP Basic Auth",
    "content": "Authelia supports two different methods for basic auth. Proxy-Authorization header . Authelia reads credentials from the header Proxy-Authorization instead of the usual Authorization header. This is because in some circumstances both Authelia and the application could require authentication in order to provide specific authorizations at the level of the application. API argument . If instead of the Proxy-Authorization header you want, or need, to use the more conventional Authorization header, you should then configure your reverse-proxy to use /api/verify?auth=basic. When authentication fails and auth=basic was set, Authelia’s response will include the WWW-Authenticate header. This will cause browsers to prompt for authentication, and users will not land on the HTML login page. ",
    "url": "/docs/features/single-factor.html#http-basic-auth",
    "relUrl": "/features/single-factor.html#http-basic-auth"
  },"195": {
    "doc": "Single Factor",
    "title": "Session-Username header",
    "content": "Authelia by default only verifies the cookie and the associated user with that cookie can access a protected resource. The client browser does not know the username and does not send this to Authelia, it’s stored by Authelia for security reasons. The Session-Username header has been implemented as a means to use Authelia with non-web services such as PAM. Basically how it works is if the Session-Username header is sent in the request to the /api/verify endpoint it will only respond with a sucess message if the cookie username and the header username match. Example . These examples are for demonstration purposes only, the original use case and full instructions are described here. You will need to adjust the FORWARDED_HOST and VERIFY_URL vars to achieve a functional result. PAM Rule . auth [success=1 default=ignore] pam_exec.so expose_authtok /usr/bin/pam-authelia . PAM Script . #!/bin/bash # The password from stdin PAM_PASSWORD=$(cat -) # url from which authelia session key was created FORWARDED_HOST=auth.example.com # internal path to verify api VERIFY_URL=http://127.0.0.1:80/api/verify AUTH_RESULT=$(curl -b \"authelia_session=${PAM_PASSWORD}\" -H \"Session-Username: ${PAM_USER}\" -H \"X-Forwarded-Host: ${FORWARDED_HOST}\" -H \"X-Forwarded-Proto: https\" -s -o /dev/null -I -w \"%{http_code}\" -L \"${VERIFY_URL}\") if [[ \"$AUTH_RESULT\" == 200 ]]; then echo \"Auth verify ok\" exit 0 else echo \"Auth verify failed $AUTH_RESULT\" exit 1 fi . ",
    "url": "/docs/features/single-factor.html#session-username-header",
    "relUrl": "/features/single-factor.html#session-username-header"
  },"196": {
    "doc": "SMTP",
    "title": "SMTP",
    "content": "Authelia can send emails to users through an SMTP server. It can be configured as described below. ",
    "url": "/docs/configuration/notifier/smtp.html",
    "relUrl": "/configuration/notifier/smtp.html"
  },"197": {
    "doc": "SMTP",
    "title": "Configuration",
    "content": "notifier: disable_startup_check: false smtp: host: 127.0.0.1 port: 1025 timeout: 5s username: test password: password sender: \"Authelia &lt;admin@example.com&gt;\" identifier: localhost subject: \"[Authelia] {title}\" startup_check_address: test@authelia.com disable_require_tls: false disable_html_emails: false tls: server_name: smtp.example.com skip_verify: false minimum_version: TLS1.2 . ",
    "url": "/docs/configuration/notifier/smtp.html#configuration",
    "relUrl": "/configuration/notifier/smtp.html#configuration"
  },"198": {
    "doc": "SMTP",
    "title": "Options",
    "content": "host . type: integer . required: yes . The hostname of the SMTP server. If utilising an IPv6 literal address it must be enclosed by square brackets and quoted: . host: \"[fd00:1111:2222:3333::1]\" . port . type: integer . required: yes . The port the SMTP service is listening on. timeout . type: duration . default: 5s . required: no . The SMTP connection timeout. username . type: string . required: no . The username sent for authentication with the SMTP server. Paired with the password. password . type: string . required: no . The password sent for authentication with the SMTP server. Paired with the username. Can also be defined using a secret which is the recommended for containerized deployments. sender . type: string . required: yes . The sender is used to construct both the SMTP command MAIL FROM and to add the FROM header. This address must be in RFC5322 format. This means it must one of two formats: . | jsmith@domain.com | John Smith jsmith@domain.com | . The MAIL FROM command sent to SMTP servers will not include the name portion, this is only set in the FROM as per specifications. identifier . type: string . default: localhost . required: no . The name to send to the SMTP server as the identifier with the HELO/EHLO command. Some SMTP providers like Google Mail reject the message if it’s localhost. subject . type: string . default: [Authelia] {title} . required: no . This is the subject Authelia will use in the email, it has a single placeholder at present {title} which should be included in all emails as it is the internal descriptor for the contents of the email. startup_check_address . type: string . default: test@authelia.com . required: no . Authelia checks the SMTP server is valid at startup, one of the checks requires we ask the SMTP server if it can send an email from us to a specific address, this is that address. No email is actually sent in the process. It is fine to leave this as is, but you can customize it if you have issues or you desire to. disable_require_tls . type: boolean . default: false . required: no . For security reasons the default settings for Authelia require the SMTP connection is encrypted by TLS. See [security] for more information. This option disables this measure (not recommended). disable_html_emails . type: boolean . default: false . required: no . This setting completely disables HTML formatting of emails and only sends text emails. Authelia by default sends mixed emails which contain both HTML and text so this option is rarely necessary. tls . Controls the TLS connection validation process. You can see how to configure the tls section here. ",
    "url": "/docs/configuration/notifier/smtp.html#options",
    "relUrl": "/configuration/notifier/smtp.html#options"
  },"199": {
    "doc": "SMTP",
    "title": "Using Gmail",
    "content": "You need to generate an app password in order to use Gmail SMTP servers. The process is described here . notifier: smtp: username: myaccount@gmail.com # Password can also be set using a secret: https://www.authelia.com/docs/configuration/secrets.html password: yourapppassword sender: admin@example.com host: smtp.gmail.com port: 587 . ",
    "url": "/docs/configuration/notifier/smtp.html#using-gmail",
    "relUrl": "/configuration/notifier/smtp.html#using-gmail"
  },"200": {
    "doc": "SQLite",
    "title": "SQLite",
    "content": "If you don’t have a SQL server, you can use SQLite. However please note that this setup will prevent you from running multiple instances of Authelia since the database will be a local file. Use of this storage provider leaves Authelia stateful. It’s important in highly available scenarios to use one of the other providers, and we highly recommend it in production environments, but this requires you setup an external database. ",
    "url": "/docs/configuration/storage/sqlite.html",
    "relUrl": "/configuration/storage/sqlite.html"
  },"201": {
    "doc": "SQLite",
    "title": "Configuration",
    "content": "storage: encryption_key: a_very_important_secret local: path: /config/db.sqlite3 . ",
    "url": "/docs/configuration/storage/sqlite.html#configuration",
    "relUrl": "/configuration/storage/sqlite.html#configuration"
  },"202": {
    "doc": "SQLite",
    "title": "Options",
    "content": "encryption_key . See the encryption_key docs. path . type: string . required: yes . The path where the SQLite3 database file will be stored. It will be created if the file does not exist. ",
    "url": "/docs/configuration/storage/sqlite.html#options",
    "relUrl": "/configuration/storage/sqlite.html#options"
  },"203": {
    "doc": "Statelessness",
    "title": "Statelessness",
    "content": "Authelia supports operating as a stateless application. This is incredibly important when running in highly available deployments like you may see in platforms like Kubernetes. ",
    "url": "/docs/features/statelessness.html",
    "relUrl": "/features/statelessness.html"
  },"204": {
    "doc": "Statelessness",
    "title": "Stateful Considerations",
    "content": "There are some components within Authelia that may optionally be made stateful by using certain providers. Examples of this are as follows: . Session Provider . Severity: BREAKING. Solution: Use a session provider other than memory (Redis). If you do not configure an external provider for the session configuration it stores the session in memory. This is unacceptable for the operation of Authelia and is thus not supported for high availability. Storage Provider . Severity: BREAKING. Solution: Use a session provider other than SQLite3 (MySQL, MariaDB, PostgreSQL). Use of the local storage provider (SQLite3) is not supported in high availability setups due to a design limitation with how SQLite3 operates. Use any of the other storage providers. Notification Provider . Severity: HIGH. Solution: Use a notification provider other than file system (SMTP). Use of the file system notification provider prevents users from several key tasks which heavily impact usability of the system, and technically reduce security. Users will be unable to reset passwords or register new 2FA devices on their own. The file system provider is not supported for high availability. Authentication Provider . Severity: MEDIUM (limiting). Solution: Use an authentication provider other than file (LDAP), or distribute the file and disable password reset. Use of the file authentication provider (YAML) is only partially supported with high availability setups. It’s recommended if you don’t use a stateless provider that you disable password reset and make sure the file is distributed to all instances. We do not support using the file type in these scenarios. ",
    "url": "/docs/features/statelessness.html#stateful-considerations",
    "relUrl": "/features/statelessness.html#stateful-considerations"
  },"205": {
    "doc": "Style Guide",
    "title": "Style Guide",
    "content": "This is a general guide to the code style we aim to abide by. This is by no means an exhaustive list and we’re constantly changing and improving it. This is also a work in progress document. For our commit messages please see our Commit Message Guidelines. ",
    "url": "/docs/contributing/style-guide.html",
    "relUrl": "/contributing/style-guide.html"
  },"206": {
    "doc": "Style Guide",
    "title": "Tools",
    "content": "We implement the following tools that help us abide by our style guide and include the configuration for them inside our repository: . | golangci-lint | yamllint | eslint | prettier | . ",
    "url": "/docs/contributing/style-guide.html#tools",
    "relUrl": "/contributing/style-guide.html#tools"
  },"207": {
    "doc": "Style Guide",
    "title": "Exceptions",
    "content": "This is a style guide not a cudgel, there are always going to be exceptions to these guidelines when it makes sense not to follow them. One notable exception is the README.md for the repository. The line length of the All Contributors individual sections are longer than 120 characters and it doesn’t make sense to apply the line length guidelines. ",
    "url": "/docs/contributing/style-guide.html#exceptions",
    "relUrl": "/contributing/style-guide.html#exceptions"
  },"208": {
    "doc": "Style Guide",
    "title": "Specific Guidelines",
    "content": "Line Length . We aim to keep all files to a maximum line length of 120 characters. This allows for most modern computer systems to display two files side by side (vertically split). As always, keep in mind you should not restrict your line length when it doesn’t make sense to. This includes but is not limited to the following file types: . | Go (*.go) | YAML (*.yml, *.yaml) | Markdown (*.md) | JavaScript (*.js) | TypeScript (*.ts, *.tsx) | . Error Strings . Error messages should follow the standard go format. This format can be found in the golang code review comments however the key points are: . | errors should not start with capital letters (excluding proper nouns, acronyms, or initialism) | errors should not end with punctuation | these restrictions do not apply to logging, only the error type itself | . Configuration Documentation . The configuration documentation has a consistent format this section describes it as best as possible. It’s recommended to check additional sections for examples. Layout . The first thing in the configuration documentation should be a description of the area. This is promptly followed by the configuration heading (h2 / indent 2) which has an example full configuration. Under the configuration example each option in the configuration needs to be documented with its own heading (h3 / indent 3). Immediately following the heading is a div with some stylized icons. The body of the section is to contain paragraphs describing the usage and information specific to that value. Example Stylized Icons: . &lt;div markdown=\"1\"&gt; type: string {: .label .label-config .label-purple } default: example {: .label .label-config .label-blue } required: no {: .label .label-config .label-green } &lt;/div&gt; . type . This section has the type of the value in a semi human readable format. Some example values are string, integer, boolean, list(string), duration. This is immediately followed by the styles .label, .label-config, .label-purple. default . This section has the default of the value if one exists, this section can be completely omitted if there is no default. This is immediately followed by the styles .label, .label-config, .label-blue. required . This section has the required status of the value and must be one of yes, no, or situational. Situational means it depends on other configuration options. If it’s situational the situational usage should be documented. This is immediately followed by the styles .label, .label-config, and a traffic lights color label, i.e. if yes .label-red, if no .label-green, or if situational .label-yellow. Storage . This section outlines some rules for storage contributions. Including but not limited to migrations, schema rules, etc. Migrations . All migrations must have an up and down migration, preferably idempotent. All migrations must be named in the following format: . V&lt;version&gt;.&lt;name&gt;.&lt;engine&gt;.&lt;direction&gt;.sql . version . A 4 digit version number, should be in sequential order. name . A name containing alphanumeric characters, underscores (treated as spaces), hyphens, and no spaces. engine . The target engine for the migration, options are all, mysql, postgres, and sqlite. Primary Key . All tables must have a primary key. This primary key must be an integer with auto increment enabled, or in the case of PostgreSQL a serial type. Table/Column Names . Table and Column names must be in snake case format. This means they must have only lowercase letters, and have words seperated by underscores. The reasoning for this is that some database engines ignore case by default and this makes it easy to be consistent with the casing. Context . All database methods should include the context attribute so that database requests that are no longer needed are terminated appropriately. ",
    "url": "/docs/contributing/style-guide.html#specific-guidelines",
    "relUrl": "/contributing/style-guide.html#specific-guidelines"
  },"209": {
    "doc": "Suites",
    "title": "Suites",
    "content": "Authelia is a single component in interaction with many others in a complete ecosystem. Consequently, testing the features is not as easy as we might think. In order to solve this problem, Authelia came up with the concept of suite which is a kind of virtual environment for Authelia and a set of tests. A suite can setup components such as nginx, redis or mariadb in which Authelia can run and be tested. This abstraction allows to prepare an environment for manual testing during development and also to craft and run integration tests efficiently. ",
    "url": "/docs/contributing/suites.html",
    "relUrl": "/contributing/suites.html"
  },"210": {
    "doc": "Suites",
    "title": "Start a suite.",
    "content": "Starting a suite called Standalone is done with the following command: . $ authelia-scripts suites setup Standalone . This command deploys the environment of the suite. ",
    "url": "/docs/contributing/suites.html#start-a-suite",
    "relUrl": "/contributing/suites.html#start-a-suite"
  },"211": {
    "doc": "Suites",
    "title": "Run tests of a suite",
    "content": "Run tests of running suite . If a suite is already running, you can simply type the test command that will run the test related to the currently running suite: . $ authelia-scripts suites test . Run tests of non-running suite . However, if no suite is running yet and you just want to run the tests of a specific suite like HighAvailability, you can do so with the next command: . # Set up the env, run the tests and tear down the env $ authelia-scripts suites test HighAvailability . Run all tests of all suites . Running all tests is easy. Make sure that no suite is already running and run: . $ authelia-scripts suites test . Run tests in headless mode . As you might have noticed, the tests are run using chromedriver and selenium. It means that the tests open an instance of Chrome that might interfere with your other activities. In order to run the tests in headless mode to avoid the interference, use the following command: . $ authelia-scripts suites test --headless . ",
    "url": "/docs/contributing/suites.html#run-tests-of-a-suite",
    "relUrl": "/contributing/suites.html#run-tests-of-a-suite"
  },"212": {
    "doc": "Suites",
    "title": "Create a suite",
    "content": "Creating a suite is as easy. Let’s take the example of the Standalone suite: . | suite_standalone.go - It defines the setup and teardown phases. It likely uses docker-compose to setup the ecosystem. This file also defines the timeouts. | suite_standalone_test.go - It defines the set of tests to run against the suite. | Standalone directory - It contains resources required by the suite and likely mounted in the containers. | . A suite can also be much more complex like setting up a complete Kubernetes ecosystem. You can check the Kubernetes suite as example. ",
    "url": "/docs/contributing/suites.html#create-a-suite",
    "relUrl": "/contributing/suites.html#create-a-suite"
  },"213": {
    "doc": "Supported Proxies",
    "title": "Support",
    "content": "Standard . Standard support includes the essential features in securing an application with Authelia such as: . | Redirecting users to the Authelia portal if they are not authenticated. | Redirecting users to the target application after authentication has occurred successfully. | . It does not include actually running Authelia as a service behind the proxy, any proxy should be compatible with serving the Authelia portal itself. Standard support is only important for protected applications. Kubernetes . While proxies that generally support Authelia outside a Kubernetes cluster, there are a few situations where that does not translate to being possible when used as an Ingress Controller. There are various reasons for this such as the reverse proxy in question does not even support running as a Kubernetes, or the required modules to perform authentication transparently to the user are not typically available inside a cluster. More information about Kubernetes deployments of Authelia can be read in the documentation. XHR Redirect . XML HTTP Requests do not typically redirect browsers when returned 30x status codes. Instead, the standard method is to return a 401 status code with a Location header. While this may seem trivial; currently there isn’t wide support for it. For example nginx’s ngx_http_auth_request_module does not seem to support this in any way. Request Method . Authelia detects the upstream request method using the X-Forwarded-Method header. Some proxies set this out of the box, some require you to configure this manually. At the present time all proxies that have Standard Support do support this. ",
    "url": "/docs/home/supported-proxies.html#support",
    "relUrl": "/home/supported-proxies.html#support"
  },"214": {
    "doc": "Supported Proxies",
    "title": "Specific proxy notes",
    "content": "HAProxy . HAProxy is only supported via a lua module. Lua is typically not available in Kubernetes. You would likely have to build your own HAProxy image. Envoy . Envoy is currently not documented however we believe it is likely to be technically supported. This should be possible via Envoy’s external authorization. Caddy . Work is being done to support Caddy 2.x, however this is a low priority. You can see the progress and try it for yourself if you’re interested. Regular feedback would accelerate this work. Apache . Apache has no module that supports this kind of authentication method. It’s not certain this would even be possible, however if anyone did something like this in the past we’d be interested in a contribution. IIS . Microsoft IIS not currently supported since no auth module exists for this purpose out-of-the-box or from any known third party. It’s likely possible but unlikely to be highly used so there is little to be gained by supporting this proxy. ",
    "url": "/docs/home/supported-proxies.html#specific-proxy-notes",
    "relUrl": "/home/supported-proxies.html#specific-proxy-notes"
  },"215": {
    "doc": "Supported Proxies",
    "title": "Supported Proxies",
    "content": "The following table is a support matrix for Authelia features and specific reverse proxies. | Proxy | Standard Support | Kubernetes Support | XHR Redirect | Request Method | . | NGINX | check_circle | check_circle | cancel | check_circle | . | Traefik 1.x | check_circle | error | check_circle | check_circle | . | Traefik 2.x | check_circle | check_circle | check_circle | check_circle | . | HAProxy | check_circle | cancel | error | check_circle | . | Envoy | error | error | error | error | . | Caddy 2.x | error | cancel | error | error | . | Apache | cancel | cancel | cancel | cancel | . | IIS | cancel | cancel | cancel | cancel | . check_circle Support confirmed, additionally these icons are links to documentation for both the Standard and Kubernetes support columns . error Support is likely and being investigated . cancel Either not supported or unlikely to be supported . ",
    "url": "/docs/home/supported-proxies.html",
    "relUrl": "/home/supported-proxies.html"
  },"216": {
    "doc": "Theme",
    "title": "Theme",
    "content": "The theme section configures the theme and style Authelia uses. ",
    "url": "/docs/configuration/theme.html",
    "relUrl": "/configuration/theme.html"
  },"217": {
    "doc": "Theme",
    "title": "Configuration",
    "content": "theme: light . ",
    "url": "/docs/configuration/theme.html#configuration",
    "relUrl": "/configuration/theme.html#configuration"
  },"218": {
    "doc": "Theme",
    "title": "Options",
    "content": "theme . type: string . default: light . required: no . There are currently 3 available themes for Authelia: . | light (default) | dark | grey | . To enable automatic switching between themes, you can set theme to auto. The theme will be set to either dark or light depending on the user’s system preference which is determined using media queries. To read more technical details about the media queries used, read the MDN. ",
    "url": "/docs/configuration/theme.html#options",
    "relUrl": "/configuration/theme.html#options"
  },"219": {
    "doc": "Threat Model",
    "title": "Threat Model",
    "content": "The design goals for Authelia is to protect access to applications by collaborating with reverse proxies to prevent attacks coming from the edge of the network. This document gives an overview of what Authelia is protecting against. Some of these ideas are expanded on or otherwise described in Security Measures. ",
    "url": "/docs/security/threat-model.html",
    "relUrl": "/security/threat-model.html"
  },"220": {
    "doc": "Threat Model",
    "title": "General assumptions",
    "content": "Authelia is considered to be running within a trusted network and it heavily relies on the first level of security provided by reverse proxies. It’s very important that you take time configuring your reverse proxy properly to get all the authentication benefits brought by Authelia. Some general security tweaks are listed in Security Measures to give you some ideas. ",
    "url": "/docs/security/threat-model.html#general-assumptions",
    "relUrl": "/security/threat-model.html#general-assumptions"
  },"221": {
    "doc": "Threat Model",
    "title": "Guarantees",
    "content": "If properly configured, Authelia guarantees the following for security of your users and your apps: . | Applications cannot be accessed without proper authorization. The access control list is highly configurable allowing administrators to guarantee the least privilege principle. | Applications can be protected with two-factor authentication in order to fight against credential theft and protect highly sensitive data or operations. | Sessions are bound in time, limiting the impact of a cookie theft. Sessions can have both soft and hard expiration time limits. With the soft limit, the user is logged out when inactive for a certain period of time. With the hard limit, the user has to authenticate again after a certain period of time, whether they were active or not. | Brute force attacks against credentials are protected thanks to a regulation mechanism temporarily blocking the user account after too many attempts and delays to the authentication process. | Identity validation is required for performing administrative actions such as registering 2FA devices, preventing attackers to pass two-factor authentication by self-registering their own device. An email with a link is sent to the user with a link providing them access to the registration flow which can only be opened by a single session. | Prevention against session fixation by regenerating a new session after each privilege elevation. | Prevention against LDAP injection by following OWASP recommendations regarding valid input characters. | Connections between Authelia and third-party components like the SMTP server, database, session cache, and LDAP server can be made over TLS to mitigate against man-in-the-middle attacks. | Validation of user group memberships gets refreshed regularly from the authentication backend (LDAP only). | . ",
    "url": "/docs/security/threat-model.html#guarantees",
    "relUrl": "/security/threat-model.html#guarantees"
  },"222": {
    "doc": "Threat Model",
    "title": "Potential future guarantees",
    "content": ". | Define and enforce a password policy (to be designed since such a policy can clash with a policy set by the LDAP server). | Detect credential theft and prevent malicious actions. | Detect session cookie theft and prevent malicious actions. | Binding session cookies to single IP addresses. | Authenticate communication between Authelia and reverse proxy. | Securely transmit authentication data to backends (OAuth2 with bearer tokens). | Protect secrets stored in the database with encryption to prevent secrets leak by database exfiltration. | Least privilege on LDAP binding operations (currently administrative user is used to bind while it could be anonymous for most operations). | Extend the check of user group memberships to authentication backends other than LDAP (File currently). | Allow administrators to configure policies regarding password resets so a compromised email account does not leave accounts vulnerable. | Allow users to view their active and past sessions to either destroy them, report malicious activity to the administrator, or both. | Allow administrators to temporarily restrict users that are suspected of being compromised no matter which backend is being used. | Log comprehensive information about user sessions so administrators can identify malicious activity and potential consequences or damage caused by identified malicious activity. | Ensure the X-Forwarded-* and X-Original-* headers are able to be trusted by allowing configuration of trusted proxy servers. | . ",
    "url": "/docs/security/threat-model.html#potential-future-guarantees",
    "relUrl": "/security/threat-model.html#potential-future-guarantees"
  },"223": {
    "doc": "Threat Model",
    "title": "Trusted environment",
    "content": "It’s important to note that Authelia is considered running in a trusted environment for two reasons: . | Requests coming to Authelia should be initiated by reverse proxies but CAN be initiated by any other server currently. There is no trusted relationship between Authelia and the reverse proxy so an attacker within the network could abuse Authelia and attack it. | Your environment should be considered trusted especially if you’re using the Remote-User, Remote-Name, Remote-Email and Remote-Groups headers to forward authentication data to your backends. These headers are transmitted unsigned to the backends, meaning a malicious user within the network could pretend to be Authelia and send those headers to bypass authentication and gain access to the service. This could be mitigated by transmitting those headers with a digital signature which could be verified by the backend however, many backends just won’t support it. It has therefore been decided to invest in OpenID Connect instead to solve that authentication delegation problem. | . ",
    "url": "/docs/security/threat-model.html#trusted-environment",
    "relUrl": "/security/threat-model.html#trusted-environment"
  },"224": {
    "doc": "Traefik 1.x",
    "title": "Traefik",
    "content": "Traefik 1.x is a reverse proxy supported by Authelia. ",
    "url": "/docs/deployment/supported-proxies/traefik1.x.html#traefik",
    "relUrl": "/deployment/supported-proxies/traefik1.x.html#traefik"
  },"225": {
    "doc": "Traefik 1.x",
    "title": "Configuration",
    "content": "Below you will find commented examples of the following configuration: . | Traefik 1.x | Authelia portal | Protected endpoint (Nextcloud) | Protected endpoint with Authorization header for basic authentication (Heimdall) | . The below configuration looks to provide examples of running Traefik 1.x with labels to protect your endpoint (Nextcloud in this case). Please ensure that you also setup the respective ACME configuration for your Traefik setup as this is not covered in the example below. Basic Authentication . Authelia provides the means to be able to authenticate your first factor via the Proxy-Authorization header. Given that this is not compatible with Traefik 1.x you can call Authelia’s /api/verify endpoint with the auth=basic query parameter to force a switch to the Authentication header. docker-compose.yml . version: '3' networks: net: driver: bridge services: traefik: image: traefik:v1.7.20-alpine container_name: traefik volumes: - /var/run/docker.sock:/var/run/docker.sock networks: - net labels: - 'traefik.frontend.rule=Host:traefik.example.com' - 'traefik.port=8081' ports: - 80:80 - 443:443 - 8081:8081 restart: unless-stopped command: - '--api' - '--api.entrypoint=api' - '--docker' - '--defaultentrypoints=https' - '--logLevel=DEBUG' - '--traefiklog=true' - '--traefiklog.filepath=/var/log/traefik.log' - '--entryPoints=Name:http Address::80' - '--entryPoints=Name:https Address::443 TLS' - '--entryPoints=Name:api Address::8081' authelia: image: authelia/authelia container_name: authelia volumes: - /path/to/authelia:/config networks: - net labels: - 'traefik.frontend.rule=Host:login.example.com' expose: - 9091 restart: unless-stopped environment: - TZ=Australia/Melbourne nextcloud: image: linuxserver/nextcloud container_name: nextcloud volumes: - /path/to/nextcloud/config:/config - /path/to/nextcloud/data:/data networks: - net labels: - 'traefik.frontend.rule=Host:nextcloud.example.com' - 'traefik.frontend.auth.forward.address=http://authelia:9091/api/verify?rd=https://login.example.com/' - 'traefik.frontend.auth.forward.trustForwardHeader=true' - 'traefik.frontend.auth.forward.authResponseHeaders=Remote-User,Remote-Groups,Remote-Name,Remote-Email' expose: - 443 restart: unless-stopped environment: - PUID=1000 - PGID=1000 - TZ=Australia/Melbourne heimdall: image: linuxserver/heimdall container_name: heimdall volumes: - /path/to/heimdall/config:/config networks: - net labels: - 'traefik.frontend.rule=Host:heimdall.example.com' - 'traefik.frontend.auth.forward.address=http://authelia:9091/api/verify?auth=basic - 'traefik.frontend.auth.forward.trustForwardHeader=true' - 'traefik.frontend.auth.forward.authResponseHeaders=Remote-User,Remote-Groups,Remote-Name,Remote-Email' expose: - 443 restart: unless-stopped environment: - PUID=1000 - PGID=1000 - TZ=Australia/Melbourne . ",
    "url": "/docs/deployment/supported-proxies/traefik1.x.html#configuration",
    "relUrl": "/deployment/supported-proxies/traefik1.x.html#configuration"
  },"226": {
    "doc": "Traefik 1.x",
    "title": "Traefik 1.x",
    "content": " ",
    "url": "/docs/deployment/supported-proxies/traefik1.x.html",
    "relUrl": "/deployment/supported-proxies/traefik1.x.html"
  },"227": {
    "doc": "Traefik 2.x",
    "title": "Traefik2",
    "content": "Traefik 2.x is a reverse proxy supported by Authelia. ",
    "url": "/docs/deployment/supported-proxies/traefik2.x.html#traefik2",
    "relUrl": "/deployment/supported-proxies/traefik2.x.html#traefik2"
  },"228": {
    "doc": "Traefik 2.x",
    "title": "Configuration",
    "content": "Below you will find commented examples of the following configuration: . | Traefik 2.x | Authelia portal | Protected endpoint (Nextcloud) | Protected endpoint with Authorization header for basic authentication (Heimdall) | . The below configuration looks to provide examples of running Traefik 2.x with labels to protect your endpoint (Nextcloud in this case). Please ensure that you also setup the respective ACME configuration for your Traefik setup as this is not covered in the example below. Basic Authentication . Authelia provides the means to be able to authenticate your first factor via the Proxy-Authorization header, this is compatible with Traefik &gt;= 2.4.1. If you are running Traefik &lt; 2.4.1, or you have a use-case which requires the use of the Authorization header/basic authentication login prompt you can call Authelia’s /api/verify endpoint with the auth=basic query parameter to force a switch to the Authentication header. docker-compose.yml . version: '3' networks: net: driver: bridge services: traefik: image: traefik:v2.2 container_name: traefik volumes: - /var/run/docker.sock:/var/run/docker.sock networks: - net labels: - 'traefik.enable=true' - 'traefik.http.routers.api.rule=Host(`traefik.example.com`)' - 'traefik.http.routers.api.entrypoints=https' - 'traefik.http.routers.api.service=api@internal' - 'traefik.http.routers.api.tls=true' ports: - 80:80 - 443:443 command: - '--api' - '--providers.docker=true' - '--providers.docker.exposedByDefault=false' - '--entrypoints.http=true' - '--entrypoints.http.address=:80' - '--entrypoints.http.http.redirections.entrypoint.to=https' - '--entrypoints.http.http.redirections.entrypoint.scheme=https' - '--entrypoints.https=true' - '--entrypoints.https.address=:443' - '--log=true' - '--log.level=DEBUG' - '--log.filepath=/var/log/traefik.log' authelia: image: authelia/authelia container_name: authelia volumes: - /path/to/authelia:/config networks: - net labels: - 'traefik.enable=true' - 'traefik.http.routers.authelia.rule=Host(`login.example.com`)' - 'traefik.http.routers.authelia.entrypoints=https' - 'traefik.http.routers.authelia.tls=true' - 'traefik.http.middlewares.authelia.forwardauth.address=http://authelia:9091/api/verify?rd=https://login.example.com/' - 'traefik.http.middlewares.authelia.forwardauth.trustForwardHeader=true' - 'traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User, Remote-Groups, Remote-Name, Remote-Email' - 'traefik.http.middlewares.authelia-basic.forwardauth.address=http://authelia:9091/api/verify?auth=basic' - 'traefik.http.middlewares.authelia-basic.forwardauth.trustForwardHeader=true' - 'traefik.http.middlewares.authelia-basic.forwardauth.authResponseHeaders=Remote-User, Remote-Groups, Remote-Name, Remote-Email' expose: - 9091 restart: unless-stopped environment: - TZ=Australia/Melbourne nextcloud: image: linuxserver/nextcloud container_name: nextcloud volumes: - /path/to/nextcloud/config:/config - /path/to/nextcloud/data:/data networks: - net labels: - 'traefik.enable=true' - 'traefik.http.routers.nextcloud.rule=Host(`nextcloud.example.com`)' - 'traefik.http.routers.nextcloud.entrypoints=https' - 'traefik.http.routers.nextcloud.tls=true' - 'traefik.http.routers.nextcloud.middlewares=authelia@docker' expose: - 443 restart: unless-stopped environment: - PUID=1000 - PGID=1000 - TZ=Australia/Melbourne heimdall: image: linuxserver/heimdall container_name: heimdall volumes: - /path/to/heimdall/config:/config networks: - net labels: - 'traefik.enable=true' - 'traefik.http.routers.heimdall.rule=Host(`heimdall.example.com`)' - 'traefik.http.routers.heimdall.entrypoints=https' - 'traefik.http.routers.heimdall.tls=true' - 'traefik.http.routers.heimdall.middlewares=authelia-basic@docker' expose: - 443 restart: unless-stopped environment: - PUID=1000 - PGID=1000 - TZ=Australia/Melbourne . ",
    "url": "/docs/deployment/supported-proxies/traefik2.x.html#configuration",
    "relUrl": "/deployment/supported-proxies/traefik2.x.html#configuration"
  },"229": {
    "doc": "Traefik 2.x",
    "title": "FAQ",
    "content": "Middleware authelia@docker not found . If Traefik and Authelia are defined in different docker compose stacks you may experience an issue where Traefik complains that: middleware authelia@docker not found. This can be avoided a couple different ways: . | Ensure Authelia container is up before Traefik is started: . | Utilise the depends_on option | . | Define the Authelia middleware on your Traefik container - 'traefik.http.middlewares.authelia.forwardauth.address=http://authelia:9091/api/verify?rd=https://login.example.com/' - 'traefik.http.middlewares.authelia.forwardauth.trustForwardHeader=true' - 'traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User, Remote-Groups, Remote-Name, Remote-Email' . | . ",
    "url": "/docs/deployment/supported-proxies/traefik2.x.html#faq",
    "relUrl": "/deployment/supported-proxies/traefik2.x.html#faq"
  },"230": {
    "doc": "Traefik 2.x",
    "title": "Traefik 2.x",
    "content": " ",
    "url": "/docs/deployment/supported-proxies/traefik2.x.html",
    "relUrl": "/deployment/supported-proxies/traefik2.x.html"
  },"231": {
    "doc": "2FA through basic auth",
    "title": "authelia-basic-2fa",
    "content": " ",
    "url": "/docs/community/two-factor-basic-auth.html#authelia-basic-2fa",
    "relUrl": "/community/two-factor-basic-auth.html#authelia-basic-2fa"
  },"232": {
    "doc": "2FA through basic auth",
    "title": "2FA through basic auth",
    "content": "The following project allows you to use Authelia’s one-time password (OTP) 2-factor authentication (2FA) through only basic auth and a custom credentials format described below. This allows you to use 2FA on clients and scenarios that demand basic auth, e.g. webdav network streaming. More information: . ",
    "url": "/docs/community/two-factor-basic-auth.html",
    "relUrl": "/community/two-factor-basic-auth.html"
  },"233": {
    "doc": "Using Remote-User header for SSO with Jira",
    "title": "Using Remote-User header for SSO with Jira",
    "content": "You can make Jira auto-login to the user that is currently logged in to authelia. I say “auto-login” as I couldn’t find any plugin to actually be authentication provider through HTTP headers only - LDAP though seems to have support. So this guide is targeted to authelia users that don’t use any other authentication backend. I’m using traefik with docker as an example, but any proxy that can forward authelia Remote-User header is fine. First of all, users should exist on both Authelia and Jira, and have the same username for this to work. Also you will have to pay for a plugin. After both steps are done: . | Add traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User in the labels of authelia | Add traefik.http.routers.jira.middlewares=authelia@docker in the labels of Jira (to actually enable Authelia for the Jira instance) | Install EasySSO in Jira | Go to EasySSO preferences and add the “Remote-User” header under HTTP and tick the “Username” checkbox. | Save | . ",
    "url": "/docs/community/using-remote-user-header-for-sso-with-jira.html",
    "relUrl": "/community/using-remote-user-header-for-sso-with-jira.html"
  },"234": {
    "doc": "Using Remote-User header for SSO with Jira",
    "title": "Other Systems",
    "content": "While this guide is tailored for Jira, you can use a similar method with many other services like Jenkins and Grafana. ",
    "url": "/docs/community/using-remote-user-header-for-sso-with-jira.html#other-systems",
    "relUrl": "/community/using-remote-user-header-for-sso-with-jira.html#other-systems"
  }
}
